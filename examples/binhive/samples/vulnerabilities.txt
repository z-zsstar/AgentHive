<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/sbin/udevd
  Taint Propagation Path:
    - Source: Environment variables from udev event (loaded via ldr r7, [r4, 0xb38] @0xa02c)
    - Step: 0xa094: strlcpy(r8, r5, 0x200) --> Copies attacker-controlled env to buffer (r8)
    - Step: 0xa0a4: bl 0xfb94 (udev_rules_apply_format) --> Expands $tokens in buffer without sanitization
    - Step: 0xa0dc: bl 0x13bb4 (run_program) --> Passes tainted buffer as param_1
    - Step: 0x13bc4: mov r6, r0 --> Stores buffer address in run_program
    - Step: 0x13eb0: ldr r0, [stack+0xfffff360] --> Loads buffer address for execv
    - Sink: 0x13eb4: bl sym.imp.execv --> Executes tainted buffer as program path
  Reason: Radare2证据链完整：1) 环境变量指针计算路径（0xa02c/0xa054）证明来源可控；2) udev_rules_apply_format反编译显示Case 0xc调用getenv()无过滤；3) run_program中execv参数直接源自初始buffer（栈偏移0xfffff360）。攻击者可通过恶意udev事件注入$env{...}标记触发任意命令执行。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/usr/sbin/l2tpd
  Taint Propagation Path:
    - Source: fgets读取/tmp/ppp/l2tpIp内容到栈缓冲区 [sp+0x1c] @ 0x0000a07c: bl sym.imp.fgets --> r5指向污点源
    - Step: 0x0000a08c: ldr r1, [0x17ae0] @ "%s %s" ; 0x0000a088: mov r3, r6 ; 0x0000a0a0: bl sym.imp.sscanf --> 解析第二字符串存入r6寄存器指向的缓冲区[sp+0x5b]
    - Step: 0x0000a0d0: beq 0xa100 ; 0x0000a104: mov r1, r6 ; 0x0000a108: bl sym.imp.strcpy --> 条件分支下复制污点数据到目标缓冲区[sp+0x158]
    - Step: 0x0000a128: mov r3, r6 ; 0x0000a12c: ldr r1, str.route_add__host__s_dev__s ; 0x0000a134: bl sym.imp.sprintf @ "route add -host %s dev %s" --> r6污点数据作为第二个%s参数构造命令
    - Sink: 0x0000a13c: bl sym.imp.system --> 执行含r6污点数据的命令
  Reason: 通过r2验证：1) fgets源缓冲区受/tmp/ppp/l2tpIp文件控制(攻击者可写)；2) sscanf解析出的第二字符串直接存入r6；3) 在0xa0d0分支满足时，strcpy将r6数据复制到新缓冲区；4) sprintf直接使用r6原始数据构造命令；5) system执行未净化的命令。POC：向文件写入'任意字符串1 恶意命令'，当strcmp匹配时触发命令执行。地址偏差(如strcpy实际在0xa108)不影响路径有效性。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/sbin/udevd
  Taint Propagation Path:
    - Source: 0x00010a9c: add r1, r1, 0x184; 0x00010aa0: bl dbg.strlcpy --> 加载外部可控的udev规则命令到缓冲区
    - Step: 0x00010ab0: bl dbg.udev_rules_apply_format --> 格式化处理污染数据（无净化）
    - Step: 0x00010ae8: bl dbg.run_program --> 将污染缓冲区传入执行函数
    - Step: 0x00013bc4: mov r6, r0 (run_program内部) --> 保存污染数据指针到r6寄存器
    - Step: 0x00013c0c: mov r1, r6; 0x00013c10: mov r0, r5; 0x00013c14: bl dbg.strlcpy --> 复制污染数据到execv参数缓冲区(r5)
    - Sink: 0x00013eb4: bl sym.imp.execv --> 执行污染命令
  Reason: 通过radare2验证：1) 污点源(0x10a9c)动态构建规则命令 2) 经udev_rules_apply_format(0x10ab0)无过滤格式化 3) 传入run_program(0x10ae8) 4) 内部通过寄存器r6传递污点(0x13bc4) 5) 复制到execv缓冲区(0x13c14) 6) 最终执行(0x13eb4)。关键证据：r2显示strlcpy在0x13c14完成污点复制，数据流连续且无净化操作。攻击者可通过篡改udev规则文件注入任意命令。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/sbin/udevd
  Taint Propagation Path:
    - Source: Device attributes from sysfs (attacker-controlled via /sys)
    - Step: 0x10a7c: ldr r1, [r4, 0x104]  --> 加载rule->field_104值
    - Step: 0x10a94: add r1, r4, r1      --> 计算基址+偏移
    - Step: 0x10a9c: add r1, r1, 0x184    --> 添加0x184固定偏移
    - Step: 0x10aa0: strlcpy(buffer, r1, 0x200)  --> 复制攻击者控制数据到缓冲区
    - Step: 0x10ab0: bl sym.udev_rules_apply_format  --> 展开$attr{...}令牌
    - Step: 0x10ae8: bl sym.run_program  --> 传入格式化后的命令缓冲区
    - Step: 0x13c14: strlcpy(local_buf, param_1, 0x200)  --> run_program内部复制污点数据
    - Step: 0x13eb0: ldr r0, [sp, 0x1c]  --> 加载命令路径指针到r0
    - Sink: 0x13eb4: bl sym.imp.execv  --> 执行未消毒命令（r0含污点数据）
  Reason: 完整证据链证明：攻击者可通过/sys控制rule->field_104+0x184处数据，经strlcpy复制后由udev_rules_apply_format处理令牌，最终通过run_program的strlcpy和参数准备直达execv。关键证据：1) 0x10a94-0x10aa0显示数据计算路径 2) run_program内部0x13c14直接复制污点输入 3) 0x13eb0-0x13eb4显示污点数据进入execv参数寄存器r0。全程无过滤操作，构成命令注入漏洞。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/sbin/udevd
  Taint Propagation Path:
    - Source: Device attributes from sysfs (attacker-controlled via /sys)
    - Step: 0x10bc0: strlcpy(r7, r4 + r1 + 0x184, 0x200) --> Copies sysfs data to buffer
    - Step: 0x10bd0: udev_rules_apply_format(r6, r7, 0x200) --> Expands $attr{...} tokens
    - Step: 0x10c20: run_program(r7, ...) --> Executes processed buffer
    - Sink: 0x13bb4: execv(program, argv) --> Directly executes attacker-controlled command
  Reason: Verified propagation path: 1) Sysfs attributes (attacker-controlled) are copied via strlcpy at 0x10bc0 (rule + rule->field_114 + 0x184 pattern). 2) Buffer undergoes token expansion in udev_rules_apply_format at 0x10bd0. 3) Expanded buffer passed to run_program at 0x10c20. 4) run_program calls execv at 0x13bb4 (confirmed via cross-references). No sanitization occurs between source and sink, making command injection possible when attacker controls device attributes.
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/sbin/curl
  Taint Propagation Path:
    - Source: 0xf62c - 用户通过命令行参数控制的文件内容 (sym.imp.fopen)
    - Step: 0x155b0: sym.imp.fgets(puVar19 - 0x1208, 0x1000, *(puVar19 - 0x1214)) --> 读取文件内容到栈缓冲区
    - Step: 0x15600: *puVar16 = 0; puVar16 = puVar16 + 1 --> 解析键值对提取污点值
    - Step: 0x1541c: bl fcn.0000df00 (r1=污点值) --> 传递污点值给配置处理函数
    - Step: fcn.0000df00@0xdf00: case 0x42分支: sym.imp.fopen64(param_2, *0xef50) --> 污点值直接作为文件名参数
    - Sink: fcn.0000df00内具体地址需定位: sym.imp.fopen64(污点值) --> 未净化用户输入作为文件名打开
  Reason: 证据链完整：1) 用户文件内容通过fgets(0x155b0)读入内存 2) 键值解析(0x15600)提取值 3) 值通过参数传递至fcn.0000df00(0x1541c) 4) 函数内case 0x42分支直接使用该参数调用fopen64。反编译显示无过滤操作，攻击者可通过构造含'B'键的配置文件控制文件名参数。POC：创建恶意配置文件，设置'B=/etc/passwd'，触发敏感文件读取。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/sbin/curl
  Taint Propagation Path:
    - Source: fgets(stdin) at 0x15528
    - Step: 0x1551c: add r0, sp, 0x1c --> 设置fgets缓冲区地址为sp+0x1c
    - Step: 0x15528: bl sym.imp.fgets --> 读取0x1000字节用户输入到sp+0x1c
    - Step: 0x1558c: add r0, r5, r8 --> 目标地址设置为堆指针(r5+r8)
    - Step: 0x15590: add r1, sp, 0x1c --> 源地址设置为受控输入缓冲区(sp+0x1c)
    - Sink: 0x15594: bl sym.imp.strcpy --> 无边界检查复制到堆地址
  Reason: 基于r2汇编证据：1) sp+0x1c缓冲区通过fgets(0x15528)完全用户可控；2) strcpy(0x15594)直接使用该缓冲区作为源，目标为动态堆地址(r5+r8)；3) 无长度校验指令（如cmp/jz）。认证用户可通过stdin输入>目标缓冲区长度的数据触发堆溢出。POC：发送4096字节数据（0x1000）到标准输入，当strcpy复制到较小堆缓冲区时导致内存破坏。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7500/_R7500v2-V1.0.3.16.img.extracted/squashfs-root/usr/sbin/e2fsck
  Taint Propagation Path:
    - Source: getenv("HOME") called at 0x27c64
    - Step: 0x27c68: subs sl, r0, 0 --> HOME值转移到sl寄存器
    - Step: 0x27c04: mov r1, sl --> sl作为源参数传递给strcpy
    - Step: 0x27c08: bl sym.imp.strcpy --> 污染数据复制到堆缓冲区(r6)
    - Step: 0x27c20: str r6, [r4, 4] --> 堆缓冲区地址存入结构体偏移4
    - Step: 0x27adc: ldr r0, [r5, 4] --> 从结构体偏移4加载污染路径指针
    - Sink: 0x27ae0: bl sym.imp.fopen --> 污染路径作为参数调用fopen
  Reason: 通过r2验证：1) 0x27c64存在getenv调用 2) 0x27c68的subs sl,r0指令真实 3) 0x27c04的mov r1,sl指令存在 4) 0x27c08的strcpy调用存在 5) 0x27c20的str r6,[r4,4]指令存在 6) 0x27adc的ldr r0,[r5,4]指令存在 7) 0x27ae0的fopen调用存在。污点传播路径完整：环境变量→寄存器→堆缓冲区→结构体→fopen参数，全程无净化操作。POC：控制HOME环境变量可指定任意路径被fopen打开。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DWR-118_V1.01b01.bin.extracted/squashfs-root/usr/sbin/pcontrol
  Taint Propagation Path:
    - Source: recvfrom(sock_fd, auStack_218c, 0x2000, 0, 0, 0) @ 0x00401fd4
    - Step: (**(iVar4 + -0x7ed4))(format_str, func_name, auStack_218c); --> Tainted data passed directly to printf-like function without sanitization [Evidence from pdg @ sym.sock_send_MAL_command]
    - Sink: printf-like function call with tainted argument (auStack_218c) and format string containing '%s'
  Reason: Radare2反编译证据显示：1) recvfrom()接收外部可控数据到栈缓冲区auStack_218c 2) 该缓冲区未经任何过滤或检查 3) 直接作为参数传递给格式化打印函数，格式字符串'...%s...'模式允许格式化字符串攻击。攻击者可通过发送特制数据触发内存破坏。POC：发送包含%n等格式化符的数据包可覆盖内存地址。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/sbin/udevd
  Taint Propagation Path:
    - Source: recvmsg receives client input to stack buffer [sp+0x8c] at 0x0000b290
    - Step: mov r5, [sp+0x8c] @0xb378 --> Loads tainted buffer address
    - Step: strchr(r5, '=') @0xb384 --> Splits input on '=' without validation (*puVar3=0)
    - Step: setenv(r5, sl, 1) @0xb40c --> Sets environment variable from unsanitized input
    - Sink: bl sym.imp.execv @0x13eb4 --> Child process inherits tainted environment variables
  Reason: Radare2证据链：1) recvmsg@0xb290接收外部输入到栈缓冲区 2) strchr@0xb384直接分割输入无验证 3) setenv@0xb40c用污染数据设置环境变量 4) execv@0x13eb4调用时继承环境变量。关键证据：axt显示无clearenv调用，环境变量始终未净化。攻击者可通过AF_UNIX发送恶意KEY=VALUE污染环境变量，影响子进程行为。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6200v2-V1.0.3.12_10.1.11/fw/_R6200v2-V1.0.3.12_10.1.11.chk.extracted/squashfs-root/usr/sbin/wlconf
  Taint Propagation Path:
    - Source: 参数param_2传入函数fcn.00009508 @0x9514 (mov sb, r1)
    - Step: 0x9548: strcpy(r5, sb)  --> 污点数据复制到栈缓冲区（sp+0xcc，大小176字节）
    - Step: 0x95ec: strcpy(r5, sb)  --> 二次复制无长度检查
    - Sink: 栈缓冲区溢出 @0x95ec  --> 当输入长度≥176字节时覆盖栈数据（返回地址@sp+0x1a0需212字节）
  Reason: 证据链确认：1) 污点源param_2（sb）在0x9514处被赋值；2) 两次strcpy均使用sb作为源（0x9548/0x95ec）；3) 目标缓冲区r5=sp+0xcc（176字节），无长度校验。攻击者可通过超长param_2触发溢出（需≥176字节），但线索中'100字节缓冲区'和'sink@0x9548'不准确：实际缓冲区176字节，且0x95ec的strcpy是直接溢出点。漏洞存在因param_2外界可控（NVRAM输入），且无净化操作。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_XR500-V2.1.0.4.img.extracted/squashfs-root/usr/sbin/afpd
  Taint Propagation Path:
    - Source: fgets(auStack_490, 1024, file_handle) @ sym.set_signature (实际地址0x2e51c附近)
    - Step: strtok(puVar7, delimiter); iVar11 = strtok_result  @ 0x2e58c (puVar7指向fgets缓冲区)
    - Step: sscanf(iVar11, format_string, param_1+0xf8,...) @ 0x2e634-0x2e66c (解析至目标缓冲区)
    - Step: sym.make_log_entry(5,3,log_id,0x2cf, param_1+0xf8) @ 0x2e438 (传递污点缓冲区)
    - Step: mov r2, r6 @ 0x49394 (污点数据加载至r6)
    - Sink: vsnprintf(sb, 0x1ff, r6,...) @ 0x493a0 (污点数据作格式化参数)
  Reason: 基于r2证据链：1) fgets读取外部可控文件内容到栈缓冲区(auStack_490)；2) strtok直接使用该缓冲区分割(puVar7=auStack_490)；3) sscanf将解析结果写入param_1+0xf8；4) 该缓冲区未经净化即传递给make_log_entry；5) 日志函数内污点数据经r6传递至vsnprintf格式化参数。关键证据：axf数据流显示auStack_490→puVar7→param_1+0xf8→r6的连续传播，且vsnprintf(0x493a0)反汇编确认r6作为格式字符串参数。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DWR-118_V1.01b01.bin.extracted/squashfs-root/usr/sbin/pcontrol
  Taint Propagation Path:
    - Source: recvfrom(*(*(iVar4 + -0x7fd0) + -0x3a6c), auStack_218c, 0x2000, 0, 0, 0) @ 函数 sock_send_MAL_command
    - Step: (**(iVar4 + -0x7ecc))(param_5, auStack_218c) --> 将接收缓冲区数据直接复制到外部参数param_5 (无长度检查)
    - Sink: unbounded buffer copy via function pointer call (等效strcpy)
  Reason: 证据链完整：1) pdg输出显示recvfrom接收0x2000字节到auStack_218c缓冲区；2) 同函数内存在直接复制操作(**(iVar4 + -0x7ecc))(param_5, auStack_218c)；3) 无任何边界检查操作；4) param_5作为函数参数由调用方控制，攻击者通过认证会话可控制输入数据长度。POC：发送>8192字节数据可触发目标缓冲区溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/usr/sbin/l2tpd
  Taint Propagation Path:
    - Source: fgets读取/tmp/ppp/l2tpIp内容到r5缓冲区 @ 0x9f64 (bl sym.imp.fgets)
    - Step: 0x9f78: bl sym.imp.strcpy --> 复制污点到r6指向的栈区(sp+0xdc)
    - Step: 0xa124: mov r2, r5 --> 加载原始污点数据到sprintf参数寄存器
    - Step: 0xa134: bl sym.imp.sprintf @ "route add -host %s dev %s" --> 直接使用r5污点构造命令
    - Sink: 0xa13c: bl sym.imp.system --> 执行含污点数据的命令
  Reason: 线索存在三处关键偏差：1) strcpy目标地址实际为sp+0xdc而非var_7c；2) sprintf直接使用原始污点r5而非栈变量；3) 污点传播未经过var_7c。但存在真实漏洞路径：fgets→r5→sprintf→system，攻击者通过控制文件内容可注入任意命令（证据：r2验证sprintf参数来自r5 @ 0xa124，system执行结果缓冲区）
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6200v2-V1.0.3.12_10.1.11/fw/_R6200v2-V1.0.3.12_10.1.11.chk.extracted/squashfs-root/usr/sbin/wlconf
  Taint Propagation Path:
    - Source: 参数param_2传入fcn.0000935c @0x935c (通过寄存器r1传入并保存至r8)
    - Step: 0x9384: mov r1, r8; mov r0, r7; bl sym.imp.strcpy --> 污点数据从r8(param_2)复制到r7指向的栈缓冲区auStack_7c[100]
    - Sink: 栈缓冲区溢出 @0x9384 --> 当param_2长度>100字节时破坏栈结构
  Reason: 基于r2反编译和汇编分析：1) 函数fcn.0000935c接收外部参数param_2（对应寄存器r8）；2) 无条件执行strcpy(r7, r8)将污点数据复制到固定100字节栈缓冲区（伪代码中auStack_7c）；3) 无长度校验或净化操作；4) 攻击者可通过控制param_2触发栈溢出。POC：构造>100字节的param_2传入该函数。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/bin/udevstart
  Taint Propagation Path:
    - Source: read系统调用在dbg.sysfs_attr_get_value (0xc4a0)读取sysfs文件内容
    - Step: 0x9c3c: bl dbg.sysfs_attr_get_value --> 获取污点数据到r0
    - Step: 0x9c54: bl sym.imp.sscanf --> 解析污点数据(r0)，结果存栈
    - Step: 0x9c60: ldr r6, [var_4h] --> 加载解析结果到r6
    - Step: 0xc4c8: mov r1, r6 --> 污点数据移入strlcat源参数(r1)
    - Step: 0xc4d0: bl sym.imp.strlcat --> 污染数据拼接到路径缓冲区(r4)
    - Sink: 0xc57c: bl sym.imp.lstat64 --> 污染路径(r4)传递给lstat64
  Reason: Radare2证据显示完整数据流：1) 0xc4a0函数通过read获取外部可控数据；2) 污点数据经sscanf解析后存入r6；3) strlcat显式使用r6作为源参数拼接路径；4) lstat64直接使用污染路径缓冲区r4。未发现任何净化操作，攻击者可通过篡改sysfs属性注入路径遍历字符(如../../etc/shadow)
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6200v2-V1.0.3.12_10.1.11/fw/_R6200v2-V1.0.3.12_10.1.11.chk.extracted/squashfs-root/usr/sbin/zip
  Taint Propagation Path:
    - Source: Command-line argument (argv[1]) received in main function via r0
    - Step: 0xa528: mov sl, r0                  ; 污染文件名存入sl寄存器
    - Step: 0xa568: bl sym.imp.malloc           ; 分配缓冲区，返回地址在r0
    - Step: 0xa570: mov r4, r0                  ; 缓冲区地址存入r4
    - Step: 0xa574: mov r7, r0                  ; 缓冲区地址同步存入r7（关键初始化）
    - Step: 0xa5cc: mov r1, sl                  ; 污染文件名移至strcat参数r1
    - Step: 0xa5d0: mov r0, r4                  ; 缓冲区地址移至strcat参数r0
    - Step: 0xa5d4: bl sym.imp.strcat           ; 污染数据拼接到缓冲区（r4/r7指向区域）
    - Step: 0xa624: mov r0, r7                  ; 污染缓冲区地址移至system参数r0
    - Sink: 0xa628: bl sym.imp.system           ; 执行污染命令
  Reason: 通过r2验证：1) r7在0xa574初始化为缓冲区地址（mov r7, r0）且后续未修改（pdf证据） 2) strcat在0xa5d4将argv[1]直接拼接到该缓冲区（pdg反编译显示无过滤） 3) system()直接使用该缓冲区执行命令（afvd显示r4/r7指向同一内存）。攻击者通过恶意文件名（如'; rm -rf /'）可注入任意命令。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/bin/udevstart
  Taint Propagation Path:
    - Source: dbg.sysfs_attr_get_value调用读取sysfs文件 (实际调用地址0xc4a0)
    - Step: 0xa998: bl dbg.sysfs_attr_get_value → 返回值存入r0
    - Step: 0xa99c: cmp r0, 0 → 检查返回值有效性
    - Sink: 0xa9a4: bl sym.imp.atoi → 污点数据(r0)直接传入atoi
  Reason: 验证失败原因：1) 线索指定地址0xc624无sysfs读取操作（实际在0xc4a0）2) 0xa9a0处指令为beq而非mov r0,r5 3) 污点传播路径与描述不符（r0直接传入atoi）。实际漏洞：sysfs_attr_get_value返回整数被当作指针传入atoi，导致任意非零返回值触发非法内存访问崩溃。POC：攻击者写入非零字节数到对应sysfs文件即可触发DoS。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DIR826LA1_FW105B13.bin.extracted/squashfs-root/bin/tc
  Taint Propagation Path:
    - Source: getenv("TC_LIB_DIR") in sym.get_tc_lib @0x00408574
    - Step: 0x0040bf54: move a3, v0 --> Tainted env value moved to a3 register
    - Step: 0x0040bf6c: snprintf(sp+0x20, 0x100, "%s/m_%s.so", a3, s1) --> Formats path with tainted env value (a3) and s1
    - Sink: 0x0040bf84: dlopen(sp+0x20, 5) --> Tainted path passed to dlopen()
  Reason: Radare2 证据确认：1) sym.get_tc_lib 通过 getenv 获取环境变量（0x00408574）；2) sym.get_action_kind 中：a) 0x0040bf54 将污染值移到 a3；b) 0x0040bf6c 用 snprintf 构造路径（格式字符串 @0x43503c 为 "%s/m_%s.so"，a3 为第一个 %s 参数）；c) 0x0040bf84 直接传递构造的路径（sp+0x20）给 dlopen。攻击者可控制 TC_LIB_DIR 环境变量，未发现净化操作，构成代码注入漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/usr/sbin/ftp
  Taint Propagation Path:
    - Source: ldr r0, str.SHELL @0xd1a0 --> bl getenv @0xd1a4 (r0="SHELL")
    - Step: subs r4, r0, 0 @0xd1a8 --> getenv返回值从r0传入r4
    - Step: mov r0, r4 @0xd210 --> tainted r4移入r0作为execl首参
    - Sink: bl sym.imp.execl @0xd224 --> tainted r0作为路径参数执行
  Reason: r2证据链完整：1) iz确认SHELL字符串存在(0xe17c)；2) pd显示0xd1a0加载SHELL地址到r0；3) 0xd1a4调用getenv返回SHELL值存r0；4) 寄存器移动指令(0xd1a8,0xd210)使污染数据直达execl首参。威胁模型成立：已认证用户可控制SHELL环境变量执行任意命令，路径中无过滤或校验。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: 环境变量IFNAME由PPP连接时攻击者控制
    - Step: 0x17a70: ldr r0, str.IFNAME ; bl sym.imp.getenv --> 加载并获取IFNAME环境变量值到r0
    - Step: 0x17a7c: movne r6, r0 --> 污点数据存入r6
    - Step: 0x17a80: mov r0, r6 --> 污点数据转入r0
    - Step: 0x17a9c: bl fcn.000106c4 --> 调用子函数并传入污点数据
    - Step: 0x106d0 (子函数): mov r5, r0 --> 污点数据保存到r5
    - Step: 0x107bc: mov r2, r5 --> 污点数据作为sprintf参数
    - Step: 0x107c0: bl sym.imp.sprintf --> 格式化污点数据到缓冲区
    - Sink: 0x107c8: bl sym.imp.system --> 执行含污点数据的命令
  Reason: 验证路径存在：1) IFNAME通过getenv获取(0x17a70)；2) 数据经寄存器传播到子函数fcn.000106c4；3) 在0x107c0的sprintf中直接格式化污点数据(r5)；4) 结果直接传入system执行(0x107c8)。关键证据：r2显示sprintf格式串为'route add default dev %s'，攻击者可通过注入分号等字符实现命令注入（如设置IFNAME='eth0;malicious_cmd'）。漏洞存在因：a) 数据来自攻击者可控环境变量；b) 无过滤/编码直接拼接命令；c) 路径终点为危险函数system。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8500/_R8500-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ver_check_ftp_username') @0xa1b0 (result: sb) --> 用户名污点源
    - Source: acosNvramConfig_get('ver_check_ftp_password') @0xa1b8 (result: r7) --> 密码污点源
    - Source: acosNvramConfig_get('ver_check_config_file') @0xa1d4 (result: sl) --> 配置文件污点源
    - Step: mov r3, sb @0xa1ec --> 用户名加载到sprintf参数寄存器
    - Step: stm sp, {r7, ip} @0xa200 --> 密码存入栈参数(第3个%s)
    - Step: str sl, [sp, #16] @0xa20c --> 配置文件存入栈参数(第7个%s)
    - Step: bl sym.imp.sprintf @0xa210 --> 执行命令拼接(format: "rm -f %s;ftpc -u %s -p %s...")
    - Sink: bl sym.imp.system(r6) @0xa218 --> 执行拼接后的完整命令
  Reason: 完整证据链证实三个NVRAM配置项直接拼接进system参数：1) 用户名作为ftpc -u参数(第2个%s) 2) 密码作为ftpc -p参数(第3个%s) 3) 配置文件嵌入-s路径(第7个%s)。POC示例：设置ver_check_config_file=';reboot;'将导致命令注入。所有污点变量均未净化，且攻击者作为认证用户可控制这些NVRAM值。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/sbin/bd
  Taint Propagation Path:
    - Source: acosNvramConfig_get("wla_wep_length") @ 0x9458 (r0 = NVRAM value) --> 外部可控输入
    - Step: bl sym.imp.atoi @ 0x945c ; mov r4, r0 @ 0x9460 --> 转换整数并存储
    - Step: ldr r1, [str.wla_key_d] @ 0x94a0 ; add r2, r4, 1 @ 0x94a4 ; bl sym.imp.sprintf @ 0x94ac --> 生成动态变量名wla_keyX
    - Step: mov r0, r5 @ 0x94b0 ; bl sym.imp.acosNvramConfig_get @ 0x94b4 --> 获取wla_keyX值
    - Sink: mov r1, r0 @ 0x94b8 ; mov r0, sp @ 0x94bc ; bl sym.imp.strcpy @ 0x94c0 --> 复制到栈缓冲区(大小0x720)
  Reason: 完整证据链验证成功：1) 栈分配指令'sub sp, sp, 0x720@0x92d0'确认缓冲区大小；2) 动态变量名构造（r4+1）使索引完全可控；3) strcpy目标地址为sp无边界检查。POC：攻击者设置wla_wep_length=1337并注入超1824字节的wla_key1337值可覆盖返回地址（距sp+0x720仅496字节）。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/local/samba/nmbd
  Taint Propagation Path:
    - Source: fgets(puVar8, 999, iVar9) at 0x20a40 in sym.poptConfigFileToString → 配置文件数据读取到栈缓冲区auStack_410 (pdg显示: puVar8 = &auStack_410)
    - Step: puVar6 = puVar8; at 0x20aa4 → 污点数据转移 (反编译: puVar6直接指向auStack_410)
    - Step: strcat(iVar2, puVar6) at 0x20bac → 污点数据拼接到堆缓冲区 (证据: iVar2=calloc(0x1e0,1)分配480字节)
    - Step: strcat(iVar2, puVar12) at 0x20cb4 → 二次污染拼接 (证据: puVar12派生自puVar6的污点数据链)
    - Sink: 多次strcat导致堆溢出 (证据: 初始分配480字节；realloc仅在拼接前触发；长度检查*(puVar15+-0x3fc)缺陷)
  Reason: 1) 污点源确认：fgets@0x20a40读取外部可控配置数据到栈缓冲区auStack_410；2) 传播路径验证：auStack_410→puVar6→strcat@0x20bac和auStack_410→puVar6→puVar12→strcat@0x20cb4两条路径均存在；3) 漏洞机制证实：初始calloc(0x1e0)分配480字节，但长度检查*(puVar15+-0x3fc)==iVar10仅在strcat前执行，攻击者可通过多行超长配置使累计长度超过480字节导致堆溢出。POC：构造含多行>480字节的配置文件触发。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8500/_R8500-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/usr/sbin/dlnad
  Taint Propagation Path:
    - Source: acosNvramConfig_get("iserver_remote_passcode") @ 0x98f8 (ldr r0, str.iserver_remote_passcode; bl sym.imp.acosNvramConfig_get)
    - Step: 0x9904: mov r2, r0 --> Tainted NVRAM value transferred from r0 to r2
    - Step: 0x990c: bl sym.imp.sprintf(r7, "echo \"NoDeviceName\r\n%s\" > /tmp/shares/forked_daapd.remote", r2) --> Untrusted data embedded via %s format specifier without sanitization
    - Step: 0x9910: mov r0, r7 --> Constructed command buffer address loaded to r0
    - Sink: 0x9914: bl sym.imp.system(r0) --> Command execution with fully tainted input
  Reason: Radare2反汇编证实：1) NVRAM值通过r0→r2直接传播；2) sprintf使用%s无过滤嵌入用户数据；3) 构造的字符串直接传入system()。威胁模型允许控制NVRAM值，通过注入';'或'`'等shell元字符可执行任意命令（如设置iserver_remote_passcode=';telnetd'）。POC：控制该NVRAM变量即可实现RCE。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/check_db
  Taint Propagation Path:
    - Source: acosNvramConfig_get(*0xa7d4) → 'ver_check_ftp_username' @0xa6fc (fcn.0000a63c)
    - Step: uVar7 = sym.imp.acosNvramConfig_get(*0xa7d4) → NVRAM值存入寄存器 @0xa6fc
    - Step: sprintf(buffer, *0xa7e4, ..., uVar7) → 污点数据拼接进命令 @0xa740 (fcn.0000a63c)
    - Sink: system(buffer) → 执行未过滤命令 @0xa758 (0xa63c+0x11c)
  Reason: 基于r2证据：1) 0xb63c处字符串为'ver_check_ftp_username'（px @0xa7d4验证指针） 2) 0xb684处格式字符串含未过滤%s占位符（psz @0xb684验证） 3) 反编译显示uVar7直接传入sprintf（pdg @fcn.0000a63c） 4) 同一buffer直接传入system。POC：攻击者设置NVRAM变量ver_check_ftp_username为'; rm -rf / #'，触发命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8900-V1.0.2.40/fw/_R8900-V1.0.2.40.img.extracted/squashfs-root/usr/bin/tar
  Taint Propagation Path:
    - Source: getenv("SHELL") returns user-controlled environment variable at 0x20864
    - Step: 0x20868: cmp r0, 0
0x2086c: ldr r4, 0x42e7d (fallback "/bin/sh")
0x20870: movne r4, r0 --> Tainted r0 (getenv result) copied to r4 if non-null
    - Step: 0x20880: mov r0, r4 --> Tainted data moved to execlp's first argument register r0
    - Sink: 0x20890: bl sym.imp.execlp --> Tainted r0 passed to execlp() as executable path
  Reason: r2反汇编(0x20860+)证实传播路径：1) getenv结果存入r0(污点源)；2) movne指令将污点r0复制到r4；3) mov指令传递r4到r0；4) execlp以r0为参数调用。路径完整匹配线索，且无数据净化操作。威胁模型下(已认证用户)可通过设置SHELL环境变量控制execlp参数。注意：0x2087c条件分支(bne 0x2089c)可能跳过sink，但该分支不净化污点数据，仅控制执行流，不影响数据传播链的有效性。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_WNR3500Lv2-V1.2.0.46_40.0.86.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: acosNvramConfig_get("ipv6_proto_auto") called via s2 @ 0x00400e44
    - Step: 0x00400e38: lw a0, -segment.LOAD0(gp) --> Load global base address
    - Step: 0x00400e48: addiu a0, a0, 0x2f34 --> Set argument to 'ipv6_proto_auto' address
    - Step: 0x00400e44: jalr t9 (t9=s2) --> Call acosNvramConfig_get, result in v0
    - Step: 0x00400e60: move a1, v0 --> Move tainted value to strcpy src argument (in delay slot)
    - Sink: 0x00400e5c: jalr t9 (t9=s1) @ sym.imp.strcpy --> Copy unchecked data to buffer
  Reason: 基于r2反汇编证据：1) 0x402f34处确认存在字符串'ipv6_proto_auto'；2) s2寄存器在0x00400df4保存acosNvramConfig_get地址，并在0x00400e40用于调用；3) strcpy调用前a1明确设置为v0（NVRAM返回值）；4) 条件分支(bnez v0)未跳转时执行路径。攻击者可通过控制函数参数(s0)使strcmp返回0触发漏洞。POC：构造输入匹配0x402f2c处字符串即可触发栈溢出。
</finding>
<finding>
  Binary Path: TP_Link/analyzed/TD_W9970_V1_150831/_TD-W9970v1_0.9.1_2.5_up_boot_2015-08-31_17.13.22.bin.extracted/squashfs-root/sbin/hotplug
  Taint Propagation Path:
    - Source: getenv("DEVPATH") @ sym.hotplug_storage_mount+0x4 (0x406940)
    - Step: 0x406940: sw v0, (var_24h) --> Store return value to stack
    - Step: 0x40694c: lw a0, (var_24h) --> Load tainted value to a0
    - Step: 0x406950: jal fcn.00401030 --> Pass tainted parameter
    - Step: [fcn.00401030] 0x4016a4: lw v0, (arg_5e0h) --> Load saved a0 (DEVPATH ptr)
    - Step: [fcn.00401030] 0x4016b0: move a1, v0 --> Set strcpy source argument
    - Sink: [fcn.00401030] 0x4016bc: jal sym.imp.strcpy --> Copy to fixed stack buffer @ fp+0x38
  Reason: 证据链完整：1) pdg 确认 DEVPATH 获取和传递；2) 汇编显示参数保存/加载路径；3) axt 验证 strcpy 调用点实际在 0x4016bc；4) move a1,v0 将污染数据传入 strcpy。攻击者通过 hotplug 事件控制 DEVPATH 可触发栈溢出。地址偏差不影响本质路径成立。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/bin/netctrl
  Taint Propagation Path:
    - Source: GetValue('wans.wanwebip') @0x13618 in fcn.00013568 (NVRAM value stored in auStack_50)
    - Step: 0x00013658: mov r0, r2 --> Sets destination to [param_1+0xc]
    - Step: 0x0001365c: mov r1, r3 --> Sets source to auStack_50 (tainted buffer)
    - Sink: strcpy @0x13660 --> Copies attacker-controlled data to 0x10-byte field (0x1c structure)
  Reason: Radare2 evidence shows: 1) 'wans.wanwebip' string reference @0x4a970 passed to GetValue; 2) Result copied to 68-byte stack buffer (auStack_50); 3) Unchecked strcpy transfers data to 16-byte field at [param_1+0xc]. POC: Set 'wans.wanwebip' >15 bytes to trigger overflow.
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/bin/speedtest
  Taint Propagation Path:
    - Source: sym.imp.GetValue('speedtest.addr.listnum', ...) @ 0x9ef8 --> NVRAM值存入栈缓冲区
    - Step: sym.imp.atoi(r3) @ 0x9f14; str r0, [sp+0x18] --> 字符串转换为整数控制循环上限
    - Step: ldr r3, [sp+0x10]; cmp r2, r3; ble 0x9f38 @ 0xa218 --> 污点值决定循环次数
    - Step: mul r2, r1, r3; add r3, r3, r2 @ 0xa0d0 --> 计算基地址+索引*0x1038偏移
    - Step: bl fcn.0000a2b0(r0, ...) @ 0x9fb8/0xa09c --> 传递污点计算地址到子函数
    - Step: add r5, r3, 4; mov r0, r5 @ 0xa35c/0xa378 --> 子函数内进行+4偏移
    - Sink: bl sym.imp.strcpy(r0, ...) @ 0xa380 --> 污点地址作为strcpy目标缓冲区
  Reason: 基于r2证据链：1) NVRAM变量'speedtest.addr.listnum'在0x9ef8被GetValue调用，返回字符串在0x9f14经atoi转换为整数控制循环上限(sp+0x18)。2) 循环索引(sp+0x10)在0xa0d0用于计算内存偏移(i*0x1038)。3) 计算结果在0x9fb8/a09c作为参数传递给fcn.0000a2b0。4) 子函数在0xa35c对地址+4后，在0xa380作为strcpy目标。攻击者通过控制NVRAM值可操纵循环索引，导致越界地址计算。未发现边界检查或净化操作，数据流完整。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8900-V1.0.2.40/fw/_R8900-V1.0.2.40.img.extracted/squashfs-root/usr/sbin/mke2fs
  Taint Propagation Path:
    - Source: getenv("ke2fs") @0xdfac → r0
    - Step: 0xdfb0: subs r7, r0, 0 → r7 = tainted value
    - Step: 0xe018: mov r1, r7 → r1 = tainted value (source string for strcat)
    - Step: 0xe01c: bl sym.imp.strcat → appends tainted string to buffer in r5
    - Step: 0xe020: mov r0, r5 → r0 = buffer (now containing tainted data) for putenv
    - Sink: 0xe024: bl sym.imp.putenv → tainted buffer passed to putenv
  Reason: 通过r2验证：1) getenv@0xdfac获取用户可控的'ke2fs'环境变量值 2) 该值经寄存器(r0→r7→r1)传递至strcat@0xe01c 3) strcat将污染数据写入r5指向的缓冲区 4) 污染缓冲区经mov@0xe020传递至putenv@0xe024。关键证据：0xe020处'mov r0, r5'直接传递污染缓冲区，且0xe01c-0xe024间无净化指令。POC：攻击者设置环境变量ke2fs=payload，触发执行后payload将被注入新环境变量。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC9V1.0BR_V15.03.05.14_multi_TD01.bin.extracted/squashfs-root/bin/multiWAN
  Taint Propagation Path:
    - Source: sym.imp.GetValue('wan1337.pppoe.pwd') at 0xc0d4 --> Returns PPPoE password in r0
    - Step: mov r3, r0 at 0xc0d8 --> Password pointer stored in r3
    - Step: Password saved to stack buffer (puVar6+iVar1-0x214) via subsequent instructions
    - Step: mov r0, r3 at 0xc368 --> Destination buffer address loaded to r0
    - Step: mov r1, r2 at 0xc36c --> Source buffer (containing password) address loaded to r1
    - Sink: bl sym.imp.strcpy at 0xc370 --> Tainted password copied without length checks
  Reason: Radare2 evidence confirms: 1) GetValue call at 0xc0d4 (pd output); 2) Direct parameter preparation for strcpy at 0xc368-0xc36c (mov r0,r3; mov r1,r2); 3) Dangerous strcpy call at 0xc370 (pd output). POC: Password from external configuration (wan1337.pppoe.pwd) flows to stack buffer via GetValue, then copied to another stack buffer via unchecked strcpy. Attackers with admin access can trigger overflow by setting long password.
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_WNR3500Lv2-V1.2.0.46_40.0.86.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: acosNvramConfig_get("ipv6_proto") @ 0x00400dec (call instruction)
    - Step: 0x00400e04: 21284000       move a1, v0 --> Moves return value (v0) from acosNvramConfig_get to strcpy source argument (a1)
    - Sink: 0x00400e08: 09f82003       jalr t9 @ sym.imp.strcpy --> Copies uncontrolled NVRAM data to buffer without sanitization
  Reason: Radare2分析证实：1) 0x00400dec处设置a0=0x00402f20('ipv6_proto')调用acosNvramConfig_get；2) 返回值v0在0x00400e04直接移入strcpy的源参数a1；3) 0x00400e08调用strcpy时使用污染数据。攻击者通过web界面设置ipv6_proto可控制该值，POC：设置超长ipv6_proto值触发缓冲区溢出。全程无长度检查或净化操作。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: recvmsg network input @ 0x9410 (fcn.00009324)
    - Step: fcn.00009dc0 @ 0x9e44: bl fcn.00009574(..., puVar4-0x408, ...) → 传递污染缓冲区
    - Step: fcn.00009574 @ 0x96c4: add r5, r5, 0x10 → 计算param_2+0x10
    - Step: fcn.00009574 @ 0x96f8: cmp r3, 5 → 检查选项类型0x05
    - Step: fcn.00009574 @ 0x97a8: ldr r3, [r5, 4] → 读取污染值(uVar17) @ param_2+0x14
    - Step: fcn.00009574 @ 0x97b0: rev r3, r3 → 字节序转换
    - Step: fcn.00009574 @ 0x97e4: bl sym.imp.sprintf(..., *(iVar12+0x30)) → 污染值嵌入命令
    - Sink: fcn.00009574 @ 0x97f0: bl sym.imp.system → 执行污染命令
  Reason: 基于r2证据链：1) 网络数据经recvmsg(0x9410)接收 2) 污染缓冲区传入fcn.00009574 3) 条件分支(0x96f8)验证选项类型0x05 4) 偏移0x14处4字节值被提取(0x97a8) 5) 该值未经净化直接用于sprintf命令拼接(0x97e4) 6) 结果缓冲区传入system执行(0x97f0)。攻击者可构造网络包控制*(param_2+0x14)值，最终注入任意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8300-V1.0.2.106_1.0.85/fw/_R8300-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/usr/bin/iperf
  Taint Propagation Path:
    - Source: bl sym.imp.getenv @ 0xefe4 (加载环境变量 IPERF_BANDWIDTH 到 r0)
    - Step: subs r1, r0, 0 @ 0xefe8 → 污点数据传入 Settings_Interpret 的 r1 参数
    - Step: bl sym.Settings_GetUpperCaseArg @ 0xe9b4 → 调用处理函数
    - Step: mov r1, r4 @ 0xe488 → 污点数据复制到 strcpy 源参数
    - Step: bl sym.imp.strcpy @ 0xe494 → 复制到栈缓冲区 [sp+0x104, sp+0x168] (100字节)
  Reason: 完整证据链验证：1) getenv 调用存在且可控 2) 污点数据通过寄存器直接传播 3) strcpy 目标为固定100字节栈缓冲区(起始 sp+0x104) 4) 无长度检查或净化操作。攻击者设置超长环境变量可覆盖返回地址。POC：IPERF_BANDWIDTH=$(python -c 'print "A"*200') ./binary
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/check_db
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ver_check_ftp_password') @0xa71c (ldr r0,[0xa7d8]; bl sym.imp.acosNvramConfig_get)
    - Step: mov r7, r0 @0xa720 --> Store password value in r7
    - Step: str r7, [sp] @0xa758 --> Push password as 3rd argument to sprintf
    - Step: bl sym.imp.sprintf @0xa748 --> Format command: 'rm -f %s;ftpc -u %s -p %s...' with password in global_buffer(r4)
    - Sink: mov r0, r4; bl sym.imp.system @0xa768 --> Execute tainted command buffer
  Reason: r2验证显示：1) 0xa71c调用acosNvramConfig_get获取NVRAM密码，返回值存r0；2) 密码经r7直接传递到sprintf参数栈(sp)；3) sprintf将未净化的密码嵌入命令模板；4) 最终通过r4将全局缓冲区传递给system执行。攻击者作为认证用户可控制'ver_check_ftp_password'值实现命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/sbin/bd
  Taint Propagation Path:
    - Source: acosNvramConfig_get("wla_defaKey") @ 0x9498 (r0 = integer string)
    - Step: bl sym.imp.atoi @ 0x949c ; convert string to integer in r0
    - Step: add r2, r0, 1 @ 0x94a4 ; calculate dynamic index in r2
    - Step: mov r0, r5; bl sym.imp.sprintf @ 0x94a8-0x94ac ; sprintf(r5, "wla_key%d", r2)
    - Step: bl sym.imp.acosNvramConfig_get @ 0x94b4 ; get tainted wla_keyX value in r0
    - Step: mov r1, r0; mov r0, sp @ 0x94b8-0x94bc ; prepare strcpy args
    - Sink: bl sym.imp.strcpy @ 0x94c0 ; unchecked copy to stack pointer
  Reason: 实际指令流验证：1) wla_defaKey经atoi转换后动态构造wla_keyX变量名；2) 二次获取的NVRAM值直接传入strcpy(sp)。攻击者作为认证用户可设置wla_defaKey(控制索引)和wla_keyX(控制内容)，通过超长字符串触发栈溢出。POC：设置wla_defaKey='1'，wla_key2=200*'A'，覆盖栈上返回地址。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/email
  Taint Propagation Path:
    - Source: acosNvramConfig_get("fw_email_email_time_type") @ 0xc5f0
    - Step: bl sym.imp.atoi @ 0xc608 --> Convert string to integer
    - Step: str r0, [r4, 0xd8] @ 0xc610 --> Store to global 0x15b74 (r4=0x15a9c)
    - Step: ldr r2, [0xc998] @ 0xc7b0 --> Load from 0x15b74 to r2
    - Sink: bl sym.imp.ioctl(fd, 0x40047b02, r2) @ 0xc7bc --> Tainted data passed to ioctl
  Reason: 通过r2验证完整传播路径：1) NVRAM读取后立即进行atoi转换(0xc608)；2) 转换结果直接存储到全局变量0x15b74(0xc610)；3) 该值未经任何处理即加载到r2(0xc7b0)；4) 直接作为ioctl的第三个参数传递(0xc7bc)。威胁模型中攻击者可修改NVRAM变量，且未发现净化操作，形成完整可控数据流。关键证据：r2指令明确从0x15b74加载(ldr r2, [0xc998] // 0xc998→0x15b74)，ioctl调用使用r2作为参数(bl sym.imp.ioctl)。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: acosNvramConfig_get("friendly_name") at 0xd704 (参数设置: 0xd6fc ldr r0, str.friendly_name)
    - Step: 0xd710: mov r3, r0 --> 污点数据存入r3寄存器
    - Step: 0xd714: ldr r2, str.echo ; 0xd718: ldr r1, str._s___s___s ; 0xd71c: mov r0, r4 ; 0xd724: bl sym.imp.sprintf --> r3(污点)作为sprintf第三参数拼接到r4缓冲区
    - Sink: 0xd728: mov r0, r4 ; 0xd72c: bl sym.imp.system --> 污点缓冲区直接传入system执行
  Reason: r2验证显示：1) 'friendly_name'通过NVRAM接口获取(0xd6fc-0xd704)；2) 返回值未经任何处理直接用于命令拼接(0xd710-0xd724)；3) 最终传入system执行(0xd72c)。格式化字符串为"%s \"%s\" %s"，污点数据位于第二个%s位置，可注入命令分隔符。攻击者可通过web界面修改NVRAM变量实现RCE。
</finding>
<finding>
  Binary Path: TP_Link/analyzed/TD_W9970_V1_150831/_TD-W9970v1_0.9.1_2.5_up_boot_2015-08-31_17.13.22.bin.extracted/squashfs-root/sbin/hotplug
  Taint Propagation Path:
    - Source: getenv("DEVPATH") at 0x00406930 in sym.hotplug_storage_mount
    - Step: 0x00406948: sw v0, (var_24h) --> 将DEVPATH指针存入栈变量
    - Step: 0x004069ac: lw a0, (var_24h) --> 加载DEVPATH指针到寄存器a0
    - Step: 0x004069b4: jal fcn.00401030 --> 调用子函数并传递污点参数
    - Step: [fcn.00401030] 0x0040104c: sw a0, (arg_5e0h) --> 保存DEVPATH指针到子函数栈帧
    - Step: [fcn.00401030] 0x004011d0: move a2, v0 --> 加载格式化字符串"/sys%s/device"地址
    - Step: [fcn.00401030] 0x004011d4: lw a3, (arg_5e0h) --> 加载DEVPATH指针作为snprintf参数
    - Sink: [fcn.00401030] 0x004011d8: jalr t9 (snprintf) --> 污点数据作为格式化字符串参数传递
  Reason: 验证路径完整：1) getenv("DEVPATH")在0x00406930被调用，结果存入栈；2) 该值通过a0传递给fcn.00401030；3) 子函数中污点数据被存储(0x0040104c)并最终加载到a3(0x004011d4)；4) 作为snprintf的格式化字符串参数传递(0x004011d8)。反编译显示无净化措施，攻击者可通过控制DEVPATH注入格式化符。威胁模型允许已认证用户控制该环境变量，构成真实漏洞。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/bin/netctrl
  Taint Propagation Path:
    - Source: GetValue('usb.samba.guest.user') @ 0x3f3d4: ldr r2, [0x0003f4c4]; mov r0, r2; mov r1, r3; bl sym.imp.GetValue --> 获取NVRAM污点数据
    - Step: 0x0003f410: mov r0, r2; mov r1, r3; bl sym.imp.strcpy --> 污点数据复制到局部缓冲区
    - Step: 0x0003f450: mov r0, r2; mov r1, r3; bl sym.tpi_write_passwd --> 传入密码处理函数
    - Step: 0x0003f8ac (sym.tpi_write_passwd): ldr r2, [s1] --> 加载污点用户名
    - Step: 0x0003f8b8: bl sym.imp.sprintf --> 拼接命令'smbpasswd -a %s -s < %s'
    - Sink: 0x0003f8c4: bl sym.imp.system --> 执行未净化的系统命令
  Reason: 污点数据从NVRAM变量'usb.samba.guest.user'(0x3f3d4)经strcpy(0x3f410)传播至sym.tpi_write_passwd。函数内部直接使用污点数据拼接命令(0x3f8b8)并执行system(0x3f8c4)，无任何净化操作。攻击者可控制NVRAM值注入恶意命令，构成命令注入漏洞。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC6V1.0BR_V15.03.05.16_multi_TD01.bin.extracted/squashfs-root/bin/multiWAN
  Taint Propagation Path:
    - Source: 0x15e0c: bl sym.imp.GetValue("lan.ip") --> Stores value in stack buffer [puVar7 -0xf4]
    - Step: 0x15e54: bl sym.imp.sprintf(s, "dnrd -a %s -r 3 -t 3 -M 600 --cache=2000:4000 -b -R /etc/dnrd", tainted_buffer) --> Formats tainted data into command buffer [s@-0x188]
    - Sink: 0x161fc: bl sym.imp.doSystemCmd(..., s, ...) --> Executes tainted command buffer without sanitization
  Reason: r2证据证实完整传播路径：1) 0x20218处存在'lan.ip'字符串；2) 0x20D84处含'%s'的格式字符串；3) 反编译显示污染缓冲区直接传递。POC：设置lan.ip为'127.0.0.1;reboot'将导致命令注入执行。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/sbin/zip
  Taint Propagation Path:
    - Source: getenv("ZIP") called at 0x22cd8 in sym.envargs (pd @0x22cd8: 'bl sym.imp.getenv')
    - Step: 0x22cdc: subs r5, r0, 0 --> 环境变量指针存入r5 (污染开始)
    - Step: 0x22a84: mov r2, r5 --> 污染指针从r5传递到r2
    - Step: 0x22ab4: mov r7, r2 --> 污染指针从r2传递到r7
    - Step: 0x22ae4: mov r0, r7 --> 设置strlen参数为污染指针r7
    - Step: 0x22ae8: bl sym.imp.strlen --> 基于污染数据计算长度
    - Step: 0x22aec: add r0, r0, 1 --> 长度+1作为分配大小
    - Step: 0x22af0: bl sym.imp.malloc --> 基于污染长度分配堆缓冲区
    - Step: 0x22b04: mov r1, r7 --> 设置strcpy源操作数为污染指针r7
    - Sink: 0x22b0c: bl sym.imp.strcpy --> 污染数据无边界检查复制到堆缓冲区 (pd @0x22b0c: 'bl sym.imp.strcpy')
  Reason: 证据链确认：1) getenv("ZIP")返回的污染指针通过r5→r2→r7传播 2) strlen(r7)使用污染数据计算长度 3) malloc分配大小由strlen(r7)+1决定 4) strcpy(r6, r7)直接复制污染数据到堆缓冲区。攻击者可设置超长ZIP环境变量触发堆溢出。线索错误描述strlen参数为r5（实际为r7），但核心漏洞路径成立。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8300-V1.0.2.106_1.0.85/fw/_R8300-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/usr/sbin/email
  Taint Propagation Path:
    - Source: fopen('/tmp/download_finish', 'r') at 0xbc44 in fcn.0000b454 (pseudo: file = fopen(*0xbe70, *0xbe74);) --> [Attacker-controlled file opened]
    - Step: fread(puVar19 - 0x514, 1, 0x400, file) in fcn.0000b454 (pseudo: fread(&stack_buf, 1, 0x400, file);) --> [File content read to stack buffer]
    - Step: strcat(iVar1, puVar19 - 0x514) in fcn.0000b454 (pseudo: strcat(heap_buf, &stack_buf);) --> [Tainted data appended to heap buffer]
    - Step: fcn.00009b40(1, *0xbe40, puVar19 - 0x114, iVar1) at 0x9b40 (pseudo: func_call(param_4=heap_buf);) --> [Tainted buffer passed as 4th argument]
    - Step: (fcn.00009b40) pcVar3 = *(iVar29 - 0x14c4); while (*pcVar3) *puVar27++ = *pcVar3++; at 0x9b40 --> [Tainted data copied to new buffer]
    - Step: fcn.000094cc(..., puVar27) call from 0x9b40 (pseudo: transmit_func(puVar27);) --> [Tainted buffer passed to network sink]
    - Sink: send(socket_fd, puVar27, length, 0) at 0x9564 or SSL_write(ssl, puVar27, length) at 0x9594 in fcn.000094cc --> [Controlled data transmitted]
  Reason: 证据链完整可复现：1) r2确认0xbe70地址包含'/tmp/download_finish'字符串 2) fcn.0000b454反编译显示文件内容通过strcat污染堆缓冲区 3) fcn.00009b40反编译证实污染数据复制到新缓冲区 4) 0x9564/0x9594地址存在send/SSL_write调用使用该缓冲区。攻击者可通过写入/tmp/download_finish文件控制网络传输内容，且路径中无净化操作。POC：echo 'payload' > /tmp/download_finish 触发传输。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6200v2-V1.0.3.12_10.1.11/fw/_R6200v2-V1.0.3.12_10.1.11.chk.extracted/squashfs-root/sbin/rc
  Taint Propagation Path:
    - Source: nvram_get("iptv_interfaces") @0x14800 --> Returns tainted string in r0
    - Step: mov r1, r0 @0x14808 --> Tainted data moved to r1 (src register)
    - Step: mov r0, r4 @0x1480c --> r4 points to stack buffer dest (auStack_b8)
    - Step: bl sym.imp.strcpy @0x14814 --> Tainted r1 passed as src to strcpy(dest, src)
    - Sink: strcpy(auStack_b8, src) @0x14814 --> Copies tainted data to fixed-size (32-byte) stack buffer
  Reason: Radare2证据链：1. pd@0x14800显示nvram_get调用；2. pd@0x14808确认污点传递到r1；3. pd@0x14814验证strcpy调用；4. pdg@fcn.00014200显示：a) dest为32字节栈缓冲区(auStack_b8)；b) 无长度检查/净化；c) 污点数据直接作为strcpy参数。攻击者(拥有合法凭证)可通过设置iptv_interfaces NVRAM变量控制src内容，溢出固定大小缓冲区。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC9V1.0BR_V15.03.05.14_multi_TD01.bin.extracted/squashfs-root/bin/multiWAN
  Taint Propagation Path:
    - Source: GetValue('wan%d.l2tp.serverip') at 0x00017c04 in sym.l2tp_connect --> Stores result in [var_350h]
    - Step: 0x00017de0: sub r2, var_350h --> Loads address of tainted IP string into r2
    - Sink: 0x00017df8: bl sym.imp.doSystemCmd --> Passes tainted IP string (via r2) to system command
  Reason: Evidence from r2 shows: (1) At 0x17c04, GetValue retrieves NVRAM variable (e.g., 'wan1.l2tp.serverip') into stack variable var_350h. (2) At 0x17de0, the address of var_350h is loaded into r2. (3) At 0x17df8, doSystemCmd is called with r2 containing the address of the unsanitized IP string. The tainted data flows directly from GetValue to a sink without sanitization, enabling command injection if the IP is attacker-controlled.
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/check_db
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ver_check_ftp_username') called at 0xb100, result stored in r7
    - Step: 0x0000b124: mov r3, r7 --> Tainted username moved to sprintf argument register
    - Step: 0x0000b144: bl sprintf(r5, "rm -f /tmp/%s;ftpc -u %s -p %s...", r4, r7, r6,...) --> Tainted data embedded in command template
    - Sink: 0x0000b14c: bl system(r5) --> Full command execution with tainted username
  Reason: Radare2反汇编显示完整证据链：1) NVRAM配置值通过0xb100获取并污点r7 2) 污点值直接移入sprintf参数r3(0xb124) 3) 在0xb144的sprintf调用中，r7对应命令模板中'-u %s'位置 4) 生成的完整命令字符串(r5)未经净化直接传入system(0xb14c)。攻击者可通过控制'ver_check_ftp_username'实现命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8500/_R8500-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: acosNvramConfig_get("ver_check_ftp_username") @ 0xa1b0 (ldr r0, [pc, #0x28c] ; bl sym.imp.acosNvramConfig_get)
    - Step: mov sb, r0 @ 0xa1b4 (污点值存储到 sb 寄存器)
    - Step: mov r3, sb @ 0xa1ec (污点数据传递到 r3 寄存器)
    - Step: sprintf(buffer, "rm -f %s;ftpc -u %s -p %s ...", r2, r3,...) @ 0xa210 (污点数据嵌入命令模板)
    - Sink: system(buffer) @ 0xa218 (bl sym.imp.system 执行污染的命令字符串)
  Reason: Radare2 证据链证明：1) 0xa28c 地址包含 ver_check_ftp_username 字符串；2) 污点数据通过寄存器直接传播未净化；3) 缓冲区直接传递至 system()。POC：攻击者设置 ver_check_ftp_username=';malicious_command;' 可实现命令注入。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DIR826LA1_FW105B13.bin.extracted/squashfs-root/bin/tc
  Taint Propagation Path:
    - Source: argv[2] loaded from command line in main @0x4046b0
    - Step: 0x4046b0: lw s2, 8(s0) --> argv[2] stored in s2 register
    - Step: 0x404748: move a0, s2 --> Tainted filename moved to a0 for freopen
    - Sink: 0x404744: jalr t9 (t9=sym.imp.freopen) --> freopen called with tainted path in a0
  Reason: Radare2分析证实：1) 0x4046b0指令'lw s2,8(s0)'直接加载argv[2]（s0=argv基址）；2) 0x404748指令'move a0,s2'将污染数据传递至参数寄存器；3) 0x404744'jalr t9'调用freopen(t9指向导入函数)。攻击者通过'--batch ../../../etc/passwd'可控制路径，威胁模型允许认证用户执行参数化命令，且路径无任何净化。POC：运行程序时注入路径遍历参数触发任意文件读取。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6200v2-V1.0.3.12_10.1.11/fw/_R6200v2-V1.0.3.12_10.1.11.chk.extracted/squashfs-root/sbin/rc
  Taint Propagation Path:
    - Source: nvram_get("iptv_interfaces") @0xee6c (r0=get result)
    - Step: 0xee78 movne r1, r0 --> Tainted data moved to strcpy src register
    - Step: 0xee7c ldr r0, [src] --> Load stack buffer address (sp+0x28) to dest register
    - Sink: 0xee80 bl sym.imp.strcpy --> Stack overflow with attacker-controlled data
  Reason: 完整证据链：1) 0xee64 ldr r0, [0x1bcdc]确认参数为"iptv_interfaces"; 2) nvram_get返回存储在r0; 3) movne指令直接传递污染数据到strcpy的r1参数; 4) ldr指令加载栈地址(sp+0x28)到r0; 5) strcpy执行无长度检查。POC：攻击者设置超长iptv_interfaces值可通过web界面触发栈溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6700-V1.0.1.36_10.0.40/fw/_R6700-V1.0.1.36_10.0.40.chk.extracted/squashfs-root/usr/sbin/dlnad
  Taint Propagation Path:
    - Source: acosNvramConfig_get("iserver_remote_passcode") @ 0x9758 → r0 = 污点值
    - Step: mov r2, r0 @ 0x9764 → 污点值移至r2
    - Step: ldr r1, [0x9b78] @ 0x9760 → r1 = "echo \"NoDeviceName\\r\\n%s\" > /tmp/shares/forked_daapd.remote"
    - Step: bl sym.imp.sprintf @ 0x976c → 污点值插入命令模板
    - Sink: bl sym.imp.system @ 0x9774 → 执行含污点数据的shell命令
  Reason: 基于r2证据链：1) 0x9758调用acosNvramConfig_get获取NVRAM值→r0；2) 0x9764将污点值(r0)移入r2；3) 0x9b78内存验证存在含%s的未过滤命令模板；4) sprintf(r7, r1, r2)将污点值直接插入命令；5) system(r7)执行最终命令。全程无净化措施，认证用户可通过设置iserver_remote_passcode注入任意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_WNR3500Lv2-V1.2.0.46_40.0.86.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: acosNvramConfig_get("ipv6_wan_ipaddr") @ 0x004012e8: uVar2 = (**(iVar14 + -0x7f5c))(iVar11 + 0x314c) --> 读取ipv6_wan_ipaddr值到uVar2
    - Source: acosNvramConfig_get("ipv6_wan_length") @ 0x00401520附近: uVar4 = (**(iVar14 + -0x7f5c))(*(iVar14 + -0x7fe4) + 0x3208) --> 读取ipv6_wan_length值到uVar4
    - Step: 0x00401520附近: (*pcVar12)(auStack_260, 0x3240, iVar10+0x3688, uVar2, uVar4) --> sprintf拼接'autoconfig_wan_up %s %s %s'命令
    - Sink: 0x00401520附近: (**(iVar14 + -0x7f28))(auStack_260) --> system执行拼接命令
  Reason: 证据链验证：1) r2反编译显示ipv6_wan_ipaddr/ipv6_wan_length通过acosNvramConfig_get获取；2) 两变量直接拼接进sprintf格式字符串；3) 未发现过滤/验证操作；4) 结果缓冲区直接传入system执行。POC：攻击者设置ipv6_wan_ipaddr=';malicious_command;'可注入命令。地址偏差因固件基址变化，但漏洞逻辑可复现。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/usr/sbin/httpd
  Taint Propagation Path:
    - Source: NVRAM variable 'http_passwd' set via authenticated configuration
    - Step: 0x7bcc4: ldr r0, str.http_passwd ; bl sym.imp.acosNvramConfig_get --> 加载http_passwd值到r0
    - Step: 0x7bcd0: mov r2, r0 ; ldr r1, str.passwd_admin_pw__s____tmp_chgpasswd --> 污点数据传入r2作为sprintf参数
    - Step: 0x7bcdc: mov r0, sp ; bl sym.imp.system --> 栈缓冲区(sp)内容作为命令执行
    - Sink: system(sp) at 0x7bce0
  Reason: 通过r2确认：1) 0x7bcc4调用acosNvramConfig_get获取http_passwd值存入r0；2) 该值经0x7bcd0的mov r2, r0传递到sprintf参数；3) sprintf将格式化命令'passwd admin pw %s > /tmp/chgpasswd'写入栈缓冲区(sp)；4) 0x7bcdc-sp地址直接传入system执行。攻击者作为认证用户可控制http_passwd值，路径中未见过滤或校验，导致任意命令注入。POC：设置http_passwd=';malicious_command;'触发命令执行。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/usr/sbin/ftp
  Taint Propagation Path:
    - Source: getenv("SHELL") called at 0xd1a4 --> Return value stored in r0 (污染源)
    - Step: 0xd1a8: subs r4, r0, 0 --> 污点数据从r0转移到r4
    - Step: 0xd208: beq 0xd258 --> 条件分支跳转至污染路径
    - Step: 0xd258: mov r0, r4 --> 污点数据从r4转移到r0
    - Sink: 0xd264: bl sym.imp.execl --> 以污染的r0作为第一参数执行危险函数
  Reason: Radare2实证完整传播链：1) 0xd1a4处getenv("SHELL")返回用户可控值至r0 2) 通过算术指令(0xd1a8)和寄存器传递(0xd258)保持污点 3) 0xd264直接以污染r0调用execl。攻击者可通过设置SHELL环境变量注入恶意路径，因已认证用户可控制环境变量，构成真实漏洞。POC：export SHELL="/path/to/malicious_binary" &&运行受影响程序。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6300/fw/_R6300v2-V1.0.4.18_10.0.84.chk.extracted/squashfs-root/usr/local/samba/nmbd
  Taint Propagation Path:
    - Source: getenv("HOME") at 0x1f394 → r7 = tainted value
    - Step: 0x1f3b8: strcpy(sp, r7) → copies tainted data to stack buffer
    - Step: 0x1f3dc: mov r1, sp → passes tainted buffer to poptReadConfigFile (arg2)
    - Step: Inside poptReadConfigFile: mov r0, r1 → transfers tainted pointer to open64 parameter
    - Sink: sym.imp.open64(r0) → uses attacker-controlled path for file access
  Reason: 验证证据：1) r2确认getenv调用和strcpy污染栈缓冲区（0x1f394-0x1f3b8）；2) poptReadConfigFile反编译显示污点指针r1直接移至r0传递至open64（无净化操作）；3) 攻击模型下HOME完全可控。未验证点：memcpy附加的字符串内容（0xffff79ec地址无效），但路径构造逻辑在反编译中可见。POC：设置HOME=../../../etc可读取passwd文件。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8900-V1.0.2.40/fw/_R8900-V1.0.2.40.img.extracted/squashfs-root/usr/sbin/mke2fs
  Taint Propagation Path:
    - Source: getenv("MKE2FS_FIRST_META_BG") @0xf940 → r0
    - Step: 0xf948: str r0, [sp, 0x60] → stack storage
    - Step: 0xfd9c: ldr r0, [sp, 0x60] → reload tainted data to r0
    - Sink: 0xfda0: bl sym.imp.free → tainted pointer passed to free()
  Reason: 通过Radare2验证：1) 0xf940调用getenv获取环境变量值存入r0；2) 0xf948将r0存储到sp+0x60栈位置；3) 0xfd9c从同栈位置重载值到r0；4) 0xfda0立即将r0传递给free。环境变量值作为指针未经任何验证直接传递至内存释放函数，攻击者通过设置MKE2FS_FIRST_META_BG环境变量可触发任意地址释放漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/usr/sbin/httpd
  Taint Propagation Path:
    - Source: NVRAM variable 'http_passwd' set via authenticated configuration
    - Step: 0x7bc9c: ldr r0, str.http_passwd ; bl sym.imp.acosNvramConfig_get --> Loads 'http_passwd' value into r0
    - Step: 0x7bca8: mov r2, r0 --> Passes tainted r0 (http_passwd) to r2 as sprintf argument
    - Step: 0x7bcac: mov r0, sp ; bl sym.imp.sprintf --> Formats string with tainted r2 into stack buffer
    - Step: 0x7bcb4: mov r0, sp --> Sets stack buffer (containing tainted data) as system argument
    - Sink: 0x7bcb8: bl sym.imp.system --> Executes command containing user-controlled http_passwd
  Reason: Radare2分析证实完整传播链：1) acosNvramConfig_get获取外部可控的http_passwd；2) 该值直接传入sprintf作为格式化参数；3) 生成的命令字符串未经任何过滤即传递至system()。认证攻击者可注入恶意命令如`$(malicious_command)`到http_passwd实现RCE。POC：设置http_passwd='$(id>/tmp/pwned)'后触发相关功能，观察/tmp/pwned文件生成。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC6V1.0BR_V15.03.05.16_multi_TD01.bin.extracted/squashfs-root/bin/multiWAN
  Taint Propagation Path:
    - Source: GetIniFileValue('wanX.isp', 'dns1') at 0x154f8 --> Stores value in stack buffer [sp+0x280]
    - Step: 0x15618: bl sym.imp.vos_strcpy --> Copies to global struct field (mov r0, r2; mov r1, r3; bl vos_strcpy)
    - Step: 0x156fc: bl sym.imp.vos_strcpy --> Reloads to local buffer [sp+0x294] (mov r0, r2; mov r1, r3; bl vos_strcpy)
    - Step: 0x15f54: bl sym.imp.sprintf(buff, ' -s %s', tainted_val) --> Formats into command component (mov r0, r2; mov r1, r3; mov r2, [value]; bl sprintf)
    - Step: 0x15f68: bl sym.imp.strcat --> Appends to main command buffer [sp+0x100] (mov r0, r2; mov r1, r3; bl strcat)
    - Sink: 0x161fc: bl sym.imp.doSystemCmd --> Executes 'dnrd -a [lan_ip] [tainted_cmd_part] &'
  Reason: Evidence from r2 analysis: 1) GetIniFileValue at 0x154f8 loads external 'dns1' value into stack. 2) Two vos_strcpy calls (0x15618, 0x156fc) propagate value without sanitization. 3) sprintf at 0x15f54 uses value with ' -s %s' format. 4) strcat at 0x15f68 incorporates it into command buffer. 5) doSystemCmd at 0x161fc executes composite command. POC: Set 'dns1=8.8.8.8;malicious_command' in wanX.isp section to trigger command injection via dnrd execution.
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: recvmsg network input in fcn.00009324 @0x9410
    - Step: 0x9e5c (fcn.00009dc0): bl fcn.00009324 → 接收数据到缓冲区
    - Step: 0x9e44 (fcn.00009dc0): bl fcn.00009574(param1, r1, ...) → 传递污点缓冲区
    - Step: fcn.00009574: if (*pcVar8 == '\x03') { puVar7 = pcVar8 + 0x10; ... } @分支逻辑
    - Step: 0x9bd4 (fcn.00009574): sym.imp.inet_ntop(10, puVar19-0x24, ...) → 转换污染地址
    - Step: 0x9bf0 (fcn.00009574): sym.imp.create_ipv6_addr(...) → 格式化地址字符串
    - Step: 0x9c18 (fcn.00009574): sym.imp.sprintf(buffer, "ifconfig %s add %s/%d", ..., puVar19-0x244) → 嵌入污染地址
    - Sink: 0x9c20 (fcn.00009574): sym.imp.system(buffer) → 执行污染命令
  Reason: 证据链验证：1) r2确认fcn.00009dc0调用fcn.00009324（0x9e5c）和fcn.00009574（0x9e44）；2) fcn.00009574反编译代码显示：当选项类型0x03时，pcVar8+0x10的污染数据经inet_ntop转换→create_ipv6_addr处理→sprintf嵌入命令模板（0xa88c的"ifconfig %s add %s/%d"）→system执行；3) 无净化操作。漏洞可利用性：攻击者可通过伪造IPv6地址（选项0x03）注入命令，如地址包含';malicious_command;'，将导致任意命令执行。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC6V1.0BR_V15.03.05.16_multi_TD01.bin.extracted/squashfs-root/bin/multiWAN
  Taint Propagation Path:
    - Source: sym.imp.GetValue('lan.ip') @0x16944 → 污点数据写入栈缓冲区[var_2ch]
    - Step: 0x1698c: bl sym.imp.sprintf(s, "dnrd -a %s -t 3 -M 600 ...", var_2ch) → 污点数据格式化到缓冲区s
    - Sink: 0x169c8: bl sym.imp.doSystemCmd("%s %s &", s, ...) → 执行污染命令
  Reason: 基于r2反汇编证据：1) 0x16944调用GetValue获取lan.ip值存储至var_2ch；2) 0x1698c使用var_2ch作为sprintf格式化参数污染命令缓冲区；3) 0x169c8直接执行该缓冲区命令。攻击者可通过配置lan.ip注入命令（如`1.1.1.1;malicious`），经dnrd命令拼接后由doSystemCmd执行。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8900-V1.0.2.40/fw/_R8900-V1.0.2.40.img.extracted/squashfs-root/usr/sbin/mke2fs
  Taint Propagation Path:
    - Source: sym.imp.getenv("E2FSPROGS_UNDO_DIR") @0x12780 → r0
    - Step: 0x12784-0x1278c: subs r5,r0; ldreq r5,[0x127a4]; addeq r5,pc,r5 → 环境变量值存入r5
    - Step: 0x12730: mov r0,r5 → 污染数据传入子函数参数
    - Step: 0x1366c-0x13684: add r0,r4,1; bl sym.imp.malloc; mov r1,r6; mov r2,r4; bl sym.imp.strncpy → 未净化复制污染数据
    - Step: 0x12738: str r0,[r4,0x1c] → 污染指针存入结构体
    - Sink: 0x15c44: bl sym.imp.open @0x15c44 → 污染路径直接用于文件打开
  Reason: 验证发现完整传播链：1) getenv返回用户可控环境变量 2) 经条件分支后值存入r5 3) 通过r0参数传入fcn.0001364c 4) 该函数使用strncpy直接复制数据（0x13684） 5) 结果指针存入结构体偏移0x1c处 6) 在fcn.00015c28中加载该指针并调用open（证据见TaskDelegator结果）。整个过程中数据未经任何路径净化，攻击者可通过注入../实现目录遍历。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/sbin/zip
  Taint Propagation Path:
    - Source: getenv("ZIPOPT") at 0xb114 (ldr r2, str.ZIPOPT) processed in sym.envargs @0xb13c
    - Step: 0xb848: ldr r1, [ptr]; bl sym.add_filter --> Passes ZIPOPT-derived value via r1
    - Step: In sym.add_filter @0xa2a4: ldrb r3, [r6, 1]; cmp r3, 0 --> Checks non-null after '@' prefix
    - Step: 0xa2b0: add r0, r6, 1 --> Constructs filename by skipping first character
    - Sink: 0xa2b8: bl sym.imp.fopen(r0, "r") --> Tainted path passed to filesystem access
  Reason: 基于r2证据链：1) ZIPOPT处理：0xb114引用"ZIPOPT"字符串，0xb13c调用sym.envargs（内含getenv调用）。2) 污点传播：0xb848将全局变量（含ZIPOPT值）加载到r1传递给sym.add_filter；函数内参数赋给r6，0xa2a4仅验证'@'后字符非空，0xa2b0直接使用r6+1作路径。3) 漏洞利用：无路径分隔符过滤，攻击者可通过ZIPOPT="@/etc/passwd"实现目录遍历。POC：合法用户设置ZIPOPT环境变量触发fopen任意文件访问。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8900-V1.0.2.40/fw/_R8900-V1.0.2.40.img.extracted/squashfs-root/usr/sbin/mke2fs
  Taint Propagation Path:
    - Source: bl sym.imp.getenv @0xdfac → r0 (获取PATH环境变量)
    - Step: 0xdfb0: subs r7, r0, 0 → r7 = tainted PATH (污染数据存入r7)
    - Step: 0xe018: mov r1, r7 → r1 = tainted data (污染数据准备拼接)
    - Step: 0xe01c: bl sym.imp.strcat → 污染数据拼接到r5缓冲区
    - Step: 0xe020: mov r0, r5 → r0 = tainted buffer (污染缓冲区移入参数寄存器)
    - Sink: 0xe024: bl sym.imp.putenv → 设置含污染数据的环变量
  Reason: 基于r2验证：1) 污染源getenv@0xdfac真实存在；2) 寄存器传播路径r0→r7→r1完整；3) strcat@0xe01c将污染数据写入r5缓冲区；4) putenv@0xe024直接使用污染缓冲区。攻击者可通过PATH注入恶意路径（如添加/tmp），导致后续进程执行劫持。POC：export PATH='/tmp:$PATH'触发漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/sbin/rc
  Taint Propagation Path:
    - Source: getenv("PHYSDEVDRIVER") at 0x1d210 → value stored in sl (r10)
    - Step: 0x1d36c ldr r1, str._s_c_d; 0x1d370 mov r2, sl; 0x1d37c bl sym.imp.sprintf → Tainted sl used to format string in r4
    - Step: 0x1d380 ldr r1, str._dev__s; 0x1d384 mov r2, r4; 0x1d388 mov r0, r5; 0x1d38c bl sym.imp.sprintf → Builds "/dev/%s" path in r5 from tainted r4
    - Step: 0x1d554 bl fcn.0001c5b8 → Passes tainted r5 (device path) to handler
    - Step: Inside fcn.0001c5b8: 0x1c628 mov r1, fp; 0x1c634 mov r0, r5; 0x1c638 bl sym.imp.strcpy → Copies tainted fp (original r5) to local buffer r5
    - Step: In caller function: 0x1c414 mov r3, r5; 0x1c41c bl sym.imp.snprintf → Formats "/lib/udev/vol_id %s" with tainted r5 into r4
    - Sink: 0x1c424 bl sym.imp.system(r4) → Executes command with injected tainted path
  Reason: 证据链完整：1) PHYSDEVDRIVER通过getenv获取(0x1d210) 2) 经两次sprintf构建设备路径(0x1d36c/0x1d38c) 3) 污点路径传入函数fcn.0001c5b8(0x1d554) 4) 函数内strcpy传播污点数据(0x1c638) 5) 最终在snprintf(0x1c41c)拼接成命令字符串，由system执行(0x1c424)。POC：设置PHYSDEVDRIVER=';malicious_command;'可注入命令，因环境变量直接拼接进vol_id命令且无过滤。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6200v2-V1.0.3.12_10.1.11/fw/_R6200v2-V1.0.3.12_10.1.11.chk.extracted/squashfs-root/sbin/rc
  Taint Propagation Path:
    - Source: getenv("PHYSDEVDRIVER") @0x189dc in fcn.00018598 (sym.imp.getenv called with string ref)
    - Step: sprintf(iVar10, format_string, getenv_result) @fcn.00018598 --> Environment variable formatted into stack buffer
    - Step: mov r0, r4 @0x188bc --> Tainted buffer moved to r0 (r4=iVar10)
    - Step: bl fcn.00017610 @0x188c0 --> Call to propagation function with tainted argument
    - Step: strncpy(puVar3 + -4, param_1, 3) @0x17664 (bl sym.imp.strncpy) --> First 3 bytes copied to local buffer
    - Step: sprintf(puVar1, "/sys/block/%s/queue/read_ahead_kb", puVar3 + -4) @0x17678 (bl sym.imp.sprintf) --> Path construction with tainted data
    - Step: sprintf(puVar3 + -0x84, "echo %d > %s", 0x400, puVar1) @0x17690 (bl sym.imp.sprintf) --> Command construction with tainted path
    - Sink: system(puVar3 + -0x84) @0x17698 (bl sym.imp.system) --> Execution of constructed command
  Reason: 验证证据链：1) 环境变量PHYSDEVDRIVER通过getenv获取（地址0x189dc）；2) 直接用于sprintf格式化（fcn.00018598）；3) 通过寄存器传递到fcn.00017610；4) 经strncpy和两次sprintf构建命令；5) 最终执行system()。关键证据：axt显示调用链，pdg证明数据流动，无过滤操作（strncpy仅复制3字节但不足以防注入）。POC：设置PHYSDEVDRIVER='xxx;id'可执行任意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/sbin/rc
  Taint Propagation Path:
    - Source: bl sym.imp.getenv("PHYSDEVDRIVER") @0x1d210 → sl register
    - Step: mov r2, sl; bl sym.imp.sprintf(r4, "%s%c%d", ...) @0x1d378 → [0x1d370] mov r2, sl; [0x1d37c] bl sprintf → Tainted sl embedded in r4
    - Step: mov r2, r4; bl sym.imp.sprintf(r5, "/dev/%s", r4) @0x1d38c → [0x1d384] mov r2, r4; [0x1d38c] bl sprintf → Forms tainted path in r5
    - Step: mov r0, r5; bl fcn.0001c3a4 @0x1c6a8 → [0x1c6a4] mov r0, r5 → Transfers tainted path to function
    - Step: mov r3, r5; bl sym.imp.snprintf(r6, ...) in fcn.0001c3a4 → [0x1c510] mov r3, r5; [0x1c51c] bl snprintf → Embeds tainted path in r6
    - Sink: mov r0, r6; bl sym.imp.system @0x1c550 → [0x1c54c] mov r0, r6; [0x1c550] bl system → Executes "mount ... <tainted_path>"
  Reason: 证据链验证：1) getenv结果通过sl寄存器传播到sprintf参数（r2指令验证）；2) 污染路径r5直接传入fcn.0001c3a4（mov r0,r5 @0x1c6a4）；3) fcn.0001c3a4内部snprintf使用r5构造命令字符串到r6（子任务4证据）；4) system执行r6包含污染路径。偏差：线索中fcn.0001c5b8未传递污染数据（子任务2证据）。漏洞成立因攻击者可通过PHYSDEVDRIVER注入命令（如'/dev/sda1;reboot;'），且路径在system前无净化。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/sbin/zip
  Taint Propagation Path:
    - Source: getenv(r6) called at 0x22cd8 --> 环境变量值存储在 r5
    - Step: 0x22cf4: mov r2, r5 --> 污点指针移至 r2
    - Step: 0x22ab4: mov r7, r2 --> 污点指针移至 r7
    - Step: 0x22ae4: mov r0, r7 --> 污点数据作 strlen 参数
    - Step: 0x22ae8: bl sym.imp.strlen --> 计算污点数据长度
    - Step: 0x22aec: add r0, r0, 1 --> 长度+1（可能整数溢出）
    - Sink: 0x22af0: bl sym.imp.malloc --> 用污染长度分配内存
  Reason: 1. 传播路径验证成功：环境变量值→strlen→malloc 路径存在
2. 漏洞可利用性：环境变量值外部可控，若长度接近 SIZE_MAX 可触发整数溢出，导致 malloc 过小缓冲区（后续 strcpy 触发堆溢出）
3. 不准确部分：未发现 "ZIP" 字符串证据（仅存在 ZIPOPT/ZIP64），r6 参数来源未在二进制中直接验证
4. 漏洞成立前提：攻击者能控制被解析的环境变量值（符合已登录用户场景）
</finding>
<finding>
  Binary Path: TP_Link/analyzed/TD_W9970_V1_150831/_TD-W9970v1_0.9.1_2.5_up_boot_2015-08-31_17.13.22.bin.extracted/squashfs-root/sbin/hotplug
  Taint Propagation Path:
    - Source: getenv("DEVPATH") at 0x406e70 in sym.hotplug_storage_umount
    - Step: 0x406eec: lw a0, [fp+0x24] --> 加载DEVPATH指针到函数参数a0
    - Step: 0x406ef4: jal fcn.00401030 --> 调用子函数传递DEVPATH
    - Step: [fcn.00401030] 0x4016a4: lw v0, [fp+0x5e0] --> 加载DEVPATH指针到v0
    - Step: [fcn.00401030] 0x4016b0: move a1, v0 --> 设置strcpy源参数为DEVPATH指针
    - Step: [fcn.00401030] 0x4016ac: move a0, v1 --> 设置strcpy目标为栈缓冲区(fp+0x38)
    - Sink: [fcn.00401030] 0x4016bc: jalr t9 (strcpy) --> 执行未边界检查的栈缓冲区复制
  Reason: 验证路径：1) DEVPATH通过getenv获取（0x406e70）；2) 作为参数传入fcn.00401030（0x406ef4）；3) 子函数中直接使用DEVPATH作为strcpy源（0x4016a4-0x4016b0）；4) 目标缓冲区为固定512字节（fp+0x38），反编译显示无长度检查。攻击者可通过环境变量注入超长字符串触发栈溢出，覆盖返回地址。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8500/_R8500-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: sym.imp.acosNvramConfig_get("ver_check_ftp_username") @ 0xa1ac (NVRAM值存入sb寄存器)
    - Step: mov r3, sb @ 0xa1ec --> 污点数据传递至sprintf参数寄存器r3
    - Step: bl sym.imp.sprintf(r6, "rm -f %s;ftpc -u %s -p %s...", ..., r3) @ 0xa210 --> 污点数据拼接到格式化字符串
    - Sink: bl sym.imp.system(r6) @ 0xa218 --> 污染缓冲区直接传入system执行
  Reason: 通过r2验证：1) 0xa28c地址确认NVRAM变量名存在；2) 0xa2a0处格式化字符串含未过滤的%s；3) 函数内完整路径：NVRAM值经寄存器直接传递至sprintf和system。认证用户可通过修改'ver_check_ftp_username'注入命令（如';reboot;'），POC：设置该NVRAM值为'admin';reboot;'将导致设备重启
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/bin/iperf
  Taint Propagation Path:
    - Source: getenv("IPERF_SINGLECLIENT") called at 0xefe4 in sym.Settings_ParseEnvironment
    - Step: 0x0000e480 mov r4, r0 --> getenv返回值存入r4
    - Step: 0x0000e488 mov r1, r4 --> 污点数据传入strcpy的src参数(r1)
    - Sink: 0x0000e494 bl sym.imp.strcpy --> 未净化数据传入缓冲区溢出高危函数
  Reason: Radare2反汇编证据链：1) getenv返回的环境变量指针通过r0传递至Settings_GetUpperCaseArg；2) 该函数内0xe480直接移动污点数据至r4；3) 0xe488将r4（污点源）作为src参数加载到r1；4) 0xe494直接调用strcpy且无长度验证。目标缓冲区(r0)来自函数参数(arg1)，反编译显示无大小校验，超长环境变量可导致栈溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/usr/sbin/httpd
  Taint Propagation Path:
    - Source: acosNvramConfig_get("max_download_speed") @ 0x881d4
    - Step: 0x881ec: mov r2, r0 --> 未净化的NVRAM值存入r2寄存器
    - Step: 0x881f0-0x881fc: add r0, var_6b0h+8; ldr r1, [0xd8e7b] ("--limit-rate=%sk"); bl sprintf --> 污点数据(r2)通过sprintf格式化到栈缓冲区
    - Step: 0x88278-0x88280: add r3, var_6b0h; add r3, r3, 8; ldr r2, [0xd8eb2] ("wget -c %s %s -O \"%s/%s\" \"%s\" &"); bl snprintf --> 污染缓冲区地址(var_6b0h+8)作为参数传递给snprintf构造命令
    - Sink: 0x88290: mov r0, r5; bl system --> 污染的命令字符串通过r5传入system()执行
  Reason: 证据链完整：1) r2反汇编确认0x881ec处mov指令传递未净化NVRAM值；2) 0x881fc处sprintf调用使用r2作为格式化参数；3) 0x88284处snprintf调用使用污染缓冲区地址(r3)；4) 伪代码显示snprintf输出直接传递给system()。攻击者可通过Web界面修改max_download_speed注入命令（如添加分号执行任意命令），构成命令注入漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/sbin/bd
  Taint Propagation Path:
    - Source: acosNvramConfig_get("wla_ssid") @ 0x9320 (r0 = NVRAM value)
    - Step: ldr r0, str.wla_ssid @ 0x9320; bl sym.imp.acosNvramConfig_get @ 0x9324; mov r1, r0 @ 0x9328 --> Tainted data moved to r1 (source for strcpy)
    - Step: mov r0, r5 @ 0x932c --> Destination: stack buffer at sp+0x400 (size 800 bytes)
    - Sink: bl sym.imp.strcpy @ 0x9330 --> Unbounded copy to stack buffer
  Reason: Radare2 证据链：
1. 函数 fcn.000092cc 在 0x9320 调用 acosNvramConfig_get("wla_ssid") 获取外部可控 NVRAM 值（攻击者可设置）
2. 返回值未经净化直接通过 r1 传递到 strcpy (0x9330)
3. 目标缓冲区为栈变量 (sp+0x400)，大小 800 字节（栈帧分配: sub sp, sp, 0x720 @ 0x92d0）
4. 返回地址保存在 sp+0x72C（push {r4,r5,r6,lr}），距缓冲区起始 812 字节
5. 无长度检查：800 字节缓冲区写入超长字符串可覆盖返回地址（需 ≥812 字节）
POC：攻击者设置超长 wla_ssid NVRAM 值触发栈溢出。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/sbin/email
  Taint Propagation Path:
    - Source: Environment variable 'EDITOR' read via getenv() at 0xb83c
    - Step: 0xb830: ldr r0, [pc, #0x1c]   ; 加载字符串'EDITOR'真实地址(0x12ab8)到r0
    - Step: 0xb83c: bl sym.imp.getenv    ; 调用getenv("EDITOR")
    - Step: 0xb840: subs r5, r0, #0       ; 结果存入r5寄存器
    - Step: 0xb994: mov r0, r5            ; 污点数据移至execlp首参数(r0)
    - Step: 0xb998: mov r1, r5            ; 污点数据移至execlp次参数(r1)
    - Sink: 0xb9a4: bl sym.imp.execlp    ; 用污染参数执行execlp(r0, r1, 0)
  Reason: r2验证证据链：1) 'EDITOR'字符串真实存在于0x12ab8；2) 指令序列完全匹配（0xb830加载地址→0xb83c调用getenv→0xb840存r5→0xb994/r0传参→0xb998/r1传参→0xb9a4执行）；3) r5寄存器在0xb840-0xb994间无修改指令；4) execlp参数直接使用污染数据。攻击者可设置EDITOR执行任意命令（如EDITOR='/bin/sh'）
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/email
  Taint Propagation Path:
    - Source: NVRAM variable 'fw_email_email_addr_2' obtained via acosNvramConfig_get
    - Step: 0x0000c7f4: ldr r0, str.fw_email_email_addr_2 ; [0xcc8c:4]=0x655f7766 --> Load NVRAM variable name address
    - Step: 0x0000c7f8: bl sym.imp.acosNvramConfig_get --> Get variable value, result in r0
    - Step: 0x0000c7fc: mov r1, r0 ; const char *src --> Move tainted data to strcpy source argument
    - Step: 0x0000c800: ldr r0, [0x0000c9a0] ; [0xc9a0:4]=0x15b30 --> Load destination buffer address
    - Sink: 0x0000c804: bl sym.imp.strcpy ; char *strcpy(char *dest, const char *src) --> Direct copy without length check
  Reason: Radare2反汇编验证：1) 指令序列完全匹配线索地址 2) 污点数据从acosNvramConfig_get返回值(r0)经mov直接传递至strcpy的src参数(r1) 3) 目标缓冲区地址从固定内存位置加载 4) 无长度检查指令(cmp/bl等) 5) NVRAM变量可由拥有合法凭证的攻击者设置。POC：设置超长fw_email_email_addr_2值可触发缓冲区溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/check_db
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ver_check_ftp_password') @0x0000b108 --> Password obtained from NVRAM config
    - Step: 0x0000b110 mov r6, r0 --> Password stored in r6; 0x0000b138 str r6, [sp] --> Password pushed as argument for sprintf
    - Step: 0x0000b144 bl sym.imp.sprintf --> Format string: 'rm -f /tmp/%s;ftpc -u %s -p %s ...' with password inserted at -p %s position
    - Sink: 0x0000b148 mov r0, r5; 0x0000b14c bl sym.imp.system --> Executes formatted command containing tainted password
  Reason: 反汇编证据显示完整传播链：1)密码通过acosNvramConfig_get获取 2)直接作为sprintf参数拼接进命令字符串 3)未净化传入system。POC：设置ver_check_ftp_password为'evil;reboot;'，最终执行'ftpc -p evil;reboot;'触发命令注入。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC9V1.0BR_V15.03.05.14_multi_TD01.bin.extracted/squashfs-root/bin/multiWAN
  Taint Propagation Path:
    - Source: sym.imp.GetValue('wl.guest.dhcps_ifname') at 0xb92c --> Stores tainted data to stack [puVar5+8-0x4a0]
    - Step: mov r0, r2; mov r1, r3 at 0xb948 --> Loads destination buffer (r0) and tainted source address (r1) from registers
    - Sink: bl sym.imp.vos_strcpy at 0xb950 --> Copies unbounded tainted data from [puVar5+8-0x4a0] to fixed stack buffer [puVar5+8-0x464]
  Reason: Radare2证据链：1) pdg显示GetValue结果直接作为vos_strcpy源参数(puVar5+8-0x4a0)；2) 汇编层0xb948-0xb94c的mov指令准备参数；3) 无边界检查：伪代码无长度验证，汇编层无校验指令；4) 目标缓冲区在栈上(auStack_468附近)，攻击者可通过'wl.guest.dhcps_ifname'完全控制输入数据长度。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DIR826LA1_FW105B13.bin.extracted/squashfs-root/bin/tc
  Taint Propagation Path:
    - Source: getenv("TC_LIB_DIR") @ sym.get_tc_lib (0x408574)
    - Step: 0x004041a4: move a3, v0 --> 污染的环境变量值从v0移至a3寄存器
    - Step: 0x004041b0-0x004041bc: snprintf(sp+0x20, 0x100, "%s/f_%s.so", a3) --> 使用污染值格式化路径
    - Step: 0x004041c8: addiu a0, sp, 0x20 --> 被污染的缓冲区地址加载到a0
    - Sink: 0x004041d4: jalr t9 → dlopen(a0) --> 污染路径传入dlopen
  Reason: 完整证据链证实：1) getenv("TC_LIB_DIR")返回用户可控值存入v0；2) 该值经寄存器传递未净化；3) 直接用于构造dlopen路径。攻击者可通过设置TC_LIB_DIR环境变量指向恶意路径实现任意库加载。POC：export TC_LIB_DIR=/malicious/path &&运行目标程序
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: getenv("DNS1") @ 0x152c4 (r0 = tainted value)
    - Step: 0x152c8: mov r1, r0 --> Tainted DNS1 value moved to r1
    - Step: 0x152cc: add r0, sp, 0xc --> Destination buffer address calculated (sp+0xc)
    - Sink: strcpy @ 0x152d0 --> Tainted data copied to fixed stack buffer without length check
  Reason: 证据链基于r2反汇编：1) getenv参数为'DNS1'（0x152c0: ldr r0, str.DNS1）；2) getenv返回值直接传递至strcpy（0x152c8: mov r1, r0）；3) 目标缓冲区通过sp+0xc计算（0x152cc: add r0, sp, 0xc），栈帧大小0x240（0x1522c: sub sp, sp, 0x240），缓冲区实际大小0x234字节；4) strcpy无前置长度检查（0x152d0: bl sym.imp.strcpy）。攻击者可通过设置超长DNS1环境变量触发栈溢出。线索中缓冲区大小描述（232字节）与实际（564字节）不符，但漏洞本质成立。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DIR826LA1_FW105B13.bin.extracted/squashfs-root/sbin/mpd
  Taint Propagation Path:
    - Source: recvfrom at 0x400d14 stores network data to sp+0x40 (s4)
    - Step: 0x400e5c: bne v0, zero, 0x401158 --> Branches to 'flash set' handler if input starts with 'flash get'
    - Step: 0x4011a4: addiu s1, sp, 0x57 --> Loads parameter value address from received data (sp+0x57) into s1
    - Step: 0x401508: move a2, s1 --> Moves tainted data (s1) to sprintf argument a2
    - Step: 0x40150c: jalr t9 (t9=0x401960) --> sprintf(sp+0xc40, "flash set %s=%s", s0, s1) constructs command with tainted data
    - Sink: 0x40156c: jalr t9 (t9=0x4018a0) --> system(sp+0xc40) executes constructed command
  Reason: Evidence chain verified via r2 analysis: 1) recvfrom@0x400d14 stores controllable data to sp+0x40 2) Branch at 0x400e5c leads to command processing 3) s1 loaded from sp+0x57 (within recv buffer) at 0x4011a4 4) s1 passed directly to sprintf@0x40150c without sanitization 5) Resulting buffer executed by system@0x40156c. POC: Send UDP packet containing 'flash set [param]=[cmd_injection]' to trigger command execution.
</finding>
<finding>
  Binary Path: Tenda/analyzed/FH1201/squashfs-root/bin/eapd
  Taint Propagation Path:
    - Source: Command-line arguments (argv) passed to main@0x004055a4
    - Step: 0x004055f8: lw t9, -sym.eapd_wksp_parse_cmd(gp); jalr t9 --> argv passed to eapd_wksp_parse_cmd@0x00404d30 via a1 register
    - Step: 0x00404db8: lw s1, 4(s2) --> argv[1] loaded to s1 (s2 holds argv pointer)
    - Step: 0x00404e9c: move a1, s1 --> Tainted argv[1] passed to subfunction@0x004034c0
    - Step: 0x00403770: move a1, s1 --> Tainted data moved to strcpy source argument
    - Sink: 0x00403778: jalr t9 @ sym.imp.strcpy --> strcpy(a0, a1) with attacker-controlled argv[1] in a1
  Reason: 验证路径存在且可利用：1) 所有关键地址存在且指令匹配；2) argv[1]作为污点源传播到strcpy未净化；3) 目标缓冲区为动态分配的60字节堆空间(0x0040373c)，无长度检查。攻击者通过命令行参数控制argv[1]可触发堆缓冲区溢出。证据链：main() -> eapd_wksp_parse_cmd() -> fcn.004034c0() -> strcpy()。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: argv[1] from command line (passed as arg2 to fcn.0001dd60)
    - Step: mov r7, r1  ; at 0x0001dd6c --> Preserve tainted argv[1] in r7
    - Step: mov r2, r7  ; at 0x0001df34 --> Move tainted data to sprintf parameter
    - Step: sprintf(buffer, "ifconfig %s del %s/%s", r2, r3, [sp]) at 0x0001df48 --> Format string injection point
    - Sink: system(buffer) at 0x0001df50 --> Execute tainted command
  Reason: 函数fcn.0001dd60在0x0001df34-0x0001df50路径中：1) r7直接来自函数参数arg2(argv[1]) 2) 通过r2传递到sprintf构造命令字符串 3) 未经验证净化即传入system执行。攻击者可构造argv[1]为'eth0;malicious_command'实现命令注入。证据链完整，POC：执行二进制时传递恶意构造的argv[1]参数。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: argv[1] loaded from [r4,4] at 0x1a290 in fcn.0001a1c0
    - Step: bl fcn.00019ce8 @0x1a298 --> Passes argv[1] as arg2 (r1) to subfunction
    - Step: mov r2, r7 @0x19eb8 --> Tainted argv[1] moved to r2 (r7 holds original arg2)
    - Step: ldr r1, str.ifconfig__s_del__s__s @0x19ec0 --> Format string "ifconfig %s del %s/%s" loaded
    - Step: bl sym.imp.sprintf @0x19ecc --> Unsanitized argv[1] embedded via r2 as first %s
    - Sink: bl sym.imp.system @0x19ed4 --> Executes constructed command with tainted input
  Reason: 验证路径：1) 函数fcn.0001a1c0在0x1a290通过ldr r1, [r4,4]获取argv[1]；2) 0x1a298调用fcn.00019ce8并传递argv[1]作为arg2；3) fcn.00019ce8在arg1≠"autoconfig"时（如"dhcp"）进入0x19ea0分支；4) 0x19eb8将argv[1]（r7）移入r2作为sprintf参数；5) 0x19ecc的sprintf将argv[1]嵌入命令字符串；6) 0x19ed4的system直接执行未净化命令。POC：传递恶意接口名如'eth0; rm -rf /'可导致命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: argv[1], argv[2], argv[3] from command line in fcn.00019f38 (0x19f38)
    - Step: ldr ip, [r5, 0xc] @ 0x1a13c; ldr r2, [r5, 4] @ 0x1a144; ldr r3, [r5, 8] @ 0x1a14c; ldr r1, 0x20f98 @ 0x1a150; bl sym.imp.sprintf @ 0x1a158 --> 使用argv[1-3]拼接未净化的命令字符串
    - Sink: mov r0, r4; bl sym.imp.system @ 0x1a168 --> 执行拼接后的命令
  Reason: Radare2反汇编显示：1. r5保存argv指针，[r5,4]对应argv[1] 2. sprintf直接使用argv[1-3]拼接格式化字符串（0x20f98处'ifconfig %s add %s/%s'）3. 拼接结果通过r4直接传入system()执行。攻击者可通过argv注入命令分隔符（如'; rm -rf /'），因无过滤机制构成命令注入漏洞。POC：运行固件时传递恶意参数如'eth0;killall telnetd; add 1.1.1.1/24'。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8500/_R8500-V1.0.2.106_1.0.85.chk.extracted/squashfs-root/bin/eapd
  Taint Propagation Path:
    - Source: nvram_get("ses_interface") in fcn.0000c8c4 @ 0xc8e8
    - Step: 0xc910: bl sym.imp.snprintf(r7, r6, "%s", r3) --> Stores tainted ses_interface value to r7 (puVar4) buffer
    - Step: 0xe03c: bl fcn.0000c8c4(r4, 0x80, str.ses_interface) --> Transfers buffer from r7 to r4 in caller context
    - Step: 0xe094: bl sym.imp.wl_ioctl(r4, 0xe, [sp+0x84], 4) --> Tainted r4 passed as 1st argument to wl_ioctl
    - Sink: Potential OS command injection via wl_ioctl device name parameter
  Reason: 证据链完整：1) 在0xc8e8获取的ses_interface值通过snprintf写入缓冲区；2) 缓冲区地址(r4)在0xe094直接作为wl_ioctl首参数传递；3) 路径中无长度检查或内容过滤。攻击者可通过修改NVRAM控制ses_interface内容，认证用户凭据符合线索前提。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-885L_fw_revA_1-13_eu_multi_20170119/_DIR885LA1_FW113b03.bin.extracted/squashfs-root/usr/sbin/iwconfig
  Taint Propagation Path:
    - Source: argv[1] stored at [var_39ch] in fcn.0000a350 (0x0000a360: str r1, [var_39ch])
    - Step: 0x0000a374: ldr r1, [var_39ch] --> Reloads tainted argv[1]
    - Step: 0x0000a37c: bl fcn.00009200 --> Passes tainted argv[1] in r1
    - Step: 0x000098b8: ldr r1, [src] --> Loads argv[1] for subcall (src=0x4c)
    - Step: 0x000098bc: bl fcn.00012428 --> Calls with tainted param_2 (r1)
    - Step: 0x0001246c: strncpy(stack_buf, r3, 0x10) --> Copies tainted data to stack buffer (r3=argv[1])
    - Step: 0x00010b94: ioctl(r0, r1, r2) --> Passes tainted stack buffer in r2 (origin: strncpy dest)
  Reason: 基于r2反汇编验证：
1. argv[1] 在fcn.0000a350入口被存储（0xa360）并重载（0xa374）
2. 传播至fcn.00009200后，在0x98b8将argv[1]加载到r1调用fcn.00012428
3. fcn.00012428在0x1246c执行 strncpy(stack_buf, argv[1], 0x10)，目标为栈缓冲区
4. 最终在fcn.00010b50的0x10b94调用 ioctl(fd, request, stack_buf)
证据链完整：用户可控的argv[1]经固定长度复制后直接传递给危险函数ioctl，存在栈缓冲区未正确终止导致的潜在内存破坏风险。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ParentalCtrl_MAC_ID_tbl') @ 0xb5a4 (通过ldr r0加载变量名地址)
    - Step: 0xb5a8: bl sym.imp.acosNvramConfig_get --> 返回污点数据到r0寄存器
    - Step: 0xb5ac: mov r1, r0 --> 污点数据转移至r1
    - Step: 0xb5b0: mov r0, r5 --> 目标缓冲区地址(r5)移至r0
    - Sink: 0xb5b4: bl sym.imp.strcpy --> 污点数据直接复制到栈缓冲区
  Reason: Radare2反汇编证据显示：1) 0xb5a4处加载NVRAM变量名后，0xb5a8立即调用acosNvramConfig_get获取外部可控数据；2) 返回数据经寄存器直接传递(0xb5ac的mov r1, r0)；3) 0xb5b4的strcpy调用未进行长度检查。结合线索提供的缓冲区大小(0xa80字节)，当NVRAM数据超过此长度时将导致栈溢出。攻击者作为认证用户可通过设置NVRAM变量触发漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: getenv("DNS1") @ 0x1577c
    - Step: 0x00015780      0070a0e1       mov r7, r0  --> getenv返回值(r0)直接移入r7
    - Step: 0x0001579c      0720a0e1       mov r2, r7  --> r7值移入r2(route_add第三参数)
    - Sink: 0x000157a4      e5d1ffeb       bl sym.imp.route_add  --> 污点数据通过r2传入
  Reason: 基于r2证据：1) DNS1获取后立即移入r7(0x15780) 2) r7直接作为route_add第三参数(0x1579c) 3) 全程无净化操作。攻击者可设置DNS1环境变量(如'0.0.0.0/0')控制路由目标。符合ARM调用约定(r0=IFNAME, r1=0, r2=DNS1, [sp]=掩码)
</finding>
<finding>
  Binary Path: Tenda/analyzed/FH1201/squashfs-root/bin/eapd
  Taint Propagation Path:
    - Source: eapd_safe_get_conf('ses_interface') @ 0x407a54: addiu a2,a2,-0x6ecc; move t9,s0; jalr t9; addiu a1,zero,0x80 --> Stores nvram value to acStack_94 (s1=sp+0x1c)
    - Step: 0x407ac8: move a0, s1 --> Tainted buffer acStack_94 passed as first argument (a0)
    - Step: 0x407ad8: jalr t9 (wl_ioctl) @ 0x408b50 --> Calls wl_ioctl(a0, 0xe, ...) with external-controlled buffer
  Reason: 证据链完整：1) 0x407a54调用eapd_safe_get_conf获取'ses_interface'值到栈变量acStack_94；2) s1寄存器（指向acStack_94）在函数中保持未变；3) 0x407ac8将s1移入a0；4) 0x407ad8调用wl_ioctl(a0,0xe)。r2反汇编显示无过滤操作（如长度检查/编码），攻击者可控制'ses_interface'内容直接传入设备控制函数。POC：设置恶意ses_interface值触发wl_ioctl异常行为。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: acosNvramConfig_get("pppoe_dhcp_dns") @ 0xda90
    - Step: ldr r0, str.pppoe_dhcp_dns; bl sym.imp.acosNvramConfig_get; mov r1, r0; mov r0, r5; bl sym.imp.strcat @ 0xda90-0xdaa0 --> NVRAM值拼接到缓冲区(r5)
    - Step: mov r1, r5; mov r0, r4; bl sym.imp.strncpy @ 0xd418-0xd420 --> 污点数据复制到新缓冲区(r4)
    - Sink: mov r0, r8; ldr r1, str.nameserver__s_n; mov r2, r4; bl sym.imp.fprintf @ 0xd8a8-0xd8b4 --> 污点数据作为参数写入配置文件
  Reason: Radare2证据显示完整传播链：1) 0xda90获取的NVRAM值通过strcat进入r5缓冲区 2) 0xd420处strncpy将r5污点数据复制到r4 3) 0xd8b4处fprintf使用r4污点数据写入文件。关键参数传递序列(mov r1,r0 → strcat, mov r2,r4 → fprintf)均获验证。攻击者作为认证用户可通过Web界面篡改pppoe_dhcp_dns值实现配置注入，无净化操作。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: fopen("/tmp/debug_sta_info", "r") at 0x8edc (file_ptr = sym.imp.fopen(0xaa44, 0xa904))
    - Step: fgets(auStack_f8, 0x80, file_ptr) at [call sym.imp.fgets] --> 文件内容读取到栈缓冲区 (偏移-0xe0)
    - Step: sscanf(auStack_f8, "%s %s", auStack_38, auStack_78) at [call sym.imp.sscanf] --> var2(auStack_78)被污染
    - Step: sprintf(auStack_1f8, "echo ==========================wl ratedump %s==============================> /dev/kmsg", auStack_78) at [call sym.imp.sprintf] --> 首次命令注入 (格式@0xacd8)
    - Sink: system(auStack_1f8) at [call sym.imp.system] --> 首次命令执行 (0x905c格式)
    - Step: sprintf(auStack_1f8, "wl ratedump %s > /dev/kmsg", auStack_78) at [call sym.imp.sprintf] --> 二次注入 (格式@0xad30)
    - Sink: system(auStack_1f8) at [call sym.imp.system] --> 二次命令执行 (0x9060格式)
  Reason: 验证证据链：1) 文件路径/模式匹配线索（0xaa44='/tmp/debug_sta_info', 0xa904='r'）；2) sscanf格式'%s %s'@0xa95c确认；3) 两个sprintf格式均含未过滤%s；4) 反编译显示auStack_78(var2)直接用于命令拼接。POC：在/tmp/debug_sta_info写入'payload1 payload2'，payload2将作为参数执行两条命令。攻击者作为认证用户可控制文件内容，实现双重命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/arp_check
  Taint Propagation Path:
    - Source: acosNvramConfig_get("wan_ifname") at 0x986c (ldr r0, [0xa63c] ; "wan_ifname")
    - Step: strcpy(sb, r0) at 0x9900 (mov r1, r0; mov r0, sb; bl sym.imp.strcpy) --> Tainted NVRAM value copied to stack buffer
    - Step: sprintf(r5, "echo \"wan up %s\" >> /tmp/wan_detect_log", sb) at 0x9914 (mov r2, sb; ldr r1, [0xa64c]; bl sym.imp.sprintf) --> Constructs command with tainted buffer
    - Sink: system(r5) at 0x991c (mov r0, r5; bl sym.imp.system) --> Executes unvalidated shell command
  Reason: 完整证据链：1) 0xa63c处字符串常量确认为"wan_ifname"（外部可控NVRAM变量）2) 0x986c调用acosNvramConfig_get获取值 3) 0x9900通过strcpy复制到栈缓冲区sb 4) 0xa64c处格式串与线索完全匹配 5) 0x9914用sb作为sprintf变量参数 6) 0x991c将构造的命令传入system执行。全程无净化操作，攻击者可控制'wan_ifname'注入任意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6700-V1.0.1.36_10.0.40/fw/_R6700-V1.0.1.36_10.0.40.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: 0x00009d30: bl sym.imp.fgets (char *fgets(char *s, int size, FILE *stream)) --> 读取攻击者控制的文件内容到栈缓冲区(r6)
    - Step: 0x00009d58: bl sym.imp.sprintf (int sprintf(char *s, const char *format, ...)) --> 构建命令字符串"rm -f %s;kill -9 %s"，其中%s直接嵌入污染数据(r6)
    - Sink: 0x00009d60: bl sym.imp.system (int system(const char *string)) --> 执行含注入payload的命令
  Reason: 在fcn.00009cd8函数中：1) 0x9d30处fgets读取用户可控的PID文件内容到栈缓冲区(r6) 2) 0x9d58处sprintf直接将r6作为参数嵌入system命令 3) 0x9d60处system执行未净化的命令。POC：攻击者写入";reboot"到PID文件，将执行"kill -9 ;reboot"触发命令注入。威胁模型下攻击者拥有合法文件写入权限，路径完整可复现。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/sbin/bzip2
  Taint Propagation Path:
    - Source: argv[0] via main() arguments (attacker-controlled program name)
    - Step: 0x0000b0b4: ldr r1, [r5] --> Loads argv[0] into r1 (r5 holds argv base)
    - Step: 0x0000b0b8: bl fcn.00008e38 --> Calls processing function with argv[0] in r1
    - Step: 0x00008e40: mov r0, r1 --> Moves argv[0] to r0 for strlen
    - Step: 0x00008e84: mov r1, r5 --> Preserves src pointer (argv[0])
    - Step: 0x00008e88: mov r2, 0x400 --> Sets copy size to 1024 bytes
    - Step: 0x00008e8c: bl sym.imp.strncpy --> Copies to global buffer at 0x21e5c (param_1)
    - Sink: 0x00008e94: strb r3, [r4, 0x400] --> Null byte write at 0x2225c (one byte beyond buffer)
  Reason: Evidence confirms: 1) argv[0] loaded at 0xb0b4 and passed to 0x8e38; 2) strncpy copies max 1024 bytes to .bss buffer at 0x21e5c; 3) Explicit null write at buffer+1024 (0x2225c) causes off-by-one overflow. Attacker with valid credentials can exploit via program name/symlink to corrupt adjacent .bss variables.
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/sbin/rdisc6
  Taint Propagation Path:
    - Source: 网络接收的数据包通过函数fcn.00009e04处理 @0x9e04
    - Step: 0x9f0c: str r3, [r6, 0x18]  ; r6=0x17268 → 污点数据存入全局地址0x17280
    - Step: 0x99c8: ldr r3, [r4, 0x18]  ; 从全局内存0x17280加载污点数据到r3
    - Step: 0x99cc: sprintf(r8, "ip -6 addr change %s/%d dev %s...", ..., r3)  ; 污点数据作为%d参数格式化
    - Sink: 0x99d4: system(r8)  ; 执行构造的命令
  Reason: r2证据确认完整传播路径：1) 网络数据通过fcn.00009e04的str指令污染全局内存0x17280 2) fcn.00009928的ldr指令加载该内存值 3) 该值直接作为sprintf的整数参数(%d)参与命令构造 4) 最终通过system执行未净化的命令。攻击者控制网络包的arg3字段可注入命令，因%d参数未过滤特殊字符。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/usr/sbin/timesync
  Taint Propagation Path:
    - Source: acosNvramConfig_get("ntp_update_interval") @ 0x00008d28 (加载参数地址)
    - Step: bl sym.imp.acosNvramConfig_get @ 0x00008d2c --> 获取NVRAM字符串到r0
    - Step: bl sym.imp.atoi @ 0x00008d30 --> 转换字符串为整数到r0
    - Step: mov r6, r0 @ 0x00008d34 --> 保存转换结果到r6寄存器
    - Step: mov r0, r6 @ 0x00008d70 --> 将污染值传递到sleep参数寄存器
    - Sink: bl sym.imp.sleep @ 0x00008d74 --> 使用污染值作为阻塞时长
  Reason: 证据链完整：1) 0x00008d28确认加载"ntp_update_interval"字符串指针；2) 0x00008d2c-0x00008d34显示NVRAM值经atoi转换后存入r6；3) 0x00008d70-0x00008d74直接使用r6值调用sleep；4) 路径可达性由0x00008c84条件分支保证；5) 无范围检查/净化指令。POC：攻击者通过NVRAM设置ntp_update_interval=2147483647可导致永久线程阻塞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8900-V1.0.2.40/fw/_R8900-V1.0.2.40.img.extracted/squashfs-root/usr/sbin/radartool
  Taint Propagation Path:
    - Source: ARGV_2 loaded via ldr r1, [r5, #8]! @0x8a74 (r5=argv)
    - Step: 0x8a80: bl sym.imp.strncpy(r0=r6+4, r1, r2=0x10) --> Copies 16 bytes to stack buffer
    - Step: 0x8ae0: mov r0, r6 --> Passes struct base address (r6) to function param
    - Step: 0x8ae4: bl fcn.00009134 --> Enters subfunction with tainted struct
    - Step: 0x9148: mov r4, r0 --> Stores struct base in r4 (subfunction prologue)
    - Step: 0x91ac: add r5, r4, #4 --> Computes tainted buffer address (r4+4 = r6+4)
    - Step: 0x91c4: mov r1, r5 --> Loads tainted address into strcpy source operand
    - Sink: 0x91d0: bl sym.imp.strcpy(dest=sp+0x20, src=r1) --> Unbounded copy with attacker-controlled source
  Reason: 基于r2指令级证据：1) 所有关键地址指令匹配线索描述 2) 函数0x9134反编译显示r0(r6)直接赋给r4 3) 污染数据从ARGV_2经strncpy复制后，作为strcpy源时无长度校验 4) strcpy目标缓冲区(sp+0x20)大小未知。攻击者通过ARGV_2注入>16字节数据可触发溢出。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DWR-118_V1.01b01.bin.extracted/squashfs-root/usr/bin/pptp-ondemand
  Taint Propagation Path:
    - Source: recv(socket_fd, buffer, 99, 0) at 0x4011e8: lw t9, -sym.imp.read(gp); jalr t9
    - Step: 0x00401210: lbu $v1, 0xc($v0); lbu $v0, 0xd($v0); sll $v0, $v0, 8; or $v0, $v0, $v1 --> 提取以太网类型（未净化），用于验证IPv4分组
    - Step: 0x00401268: lw $v0, 0x10($v0) --> 从IP头加载源IP（32位网络字节序）
    - Step: 0x00401294: jalr $t9 (inet_ntoa) --> 源IP转为字符串
    - Step: 0x004012b4: jalr $t9 (strcpy) --> 复制源IP字符串到栈缓冲区fp+0x17c
    - Step: 0x004012dc: lw $v0, 0xc($v0) --> 从IP头加载目的IP（32位网络字节序）
    - Step: 0x004012f0: jalr $t9 (inet_ntoa) --> 目的IP转为字符串
    - Step: 0x00401300: jalr $t9 (strcpy) --> 复制目的IP字符串到栈缓冲区fp+0x18c
    - Step: 0x004015d8: jalr $t9 (sprintf) --> 格式化命令：sprintf(cmd_buf, "logger -p 8.7 -t \"pptpc\" \"received...%s...%s\"", fp+0x50, fp+0x18c, fp+0x17c)
    - Sink: 0x004015fc: jalr $t9 (system) --> 执行命令：system(cmd_buf)
  Reason: 验证确认：1) recv(0x4011e8)接收未验证网络数据；2) 源/目的IP从分组提取后未经净化直接转换为字符串；3) 这些字符串在0x4015d8处拼接到logger命令中；4) 最终通过system(0x4015fc)执行。攻击者可控制IP字段注入命令（如';cmd;'）。证据：分组数据→源IP(0x401268)→strcpy(0x4012b4)→sprintf格式化参数(0x4015d8)→system参数(0x4015fc)。线索中system地址(0x4015c0)实际为sprintf参数设置指令，属部分准确。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_WNR3500Lv2-V1.2.0.46_40.0.86.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ipv6_proto') at 0x400df0
    - Step: 0x400de8: lw t9, -sym.imp.acosNvramConfig_get(gp) ; 0x400df0: jalr t9 --> 调用 NVRAM 获取函数，返回值存入 v0
    - Step: 0x400e04: move a1, v0 --> 污点数据(v0)直接传入 strcpy 的源参数(a1)
    - Sink: 0x400e00: lw t9, -sym.imp.strcpy(gp) ; 0x400e08: jalr t9 --> strcpy(dest, src) 执行污染数据复制
  Reason: 证据链确认：1) 0x402f20 处存在字符串 'ipv6_proto'（通过 iz 验证）；2) acosNvramConfig_get 返回的 v0 直接经 move a1, v0 传入 strcpy；3) 无长度校验指令（如 strlen 或边界检查）。攻击者可通过写入 NVRAM 控制 'ipv6_proto' 内容，构造超长字符串触发缓冲区溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/bin/eapd
  Taint Propagation Path:
    - Source: sym.imp.recv in fcn.0000bd88 @ 0xc58c (接收网络数据到r8缓冲区)
    - Step: 0xc584: mov r1, r8 --> 设置recv缓冲区参数
    - Step: 0xc58c: bl sym.imp.recv --> 污染数据输入（来源）
    - Step: 0xc9d4: mov r1, r8 --> 传递污染指针到调用参数
    - Step: 0xc9d8: bl fcn.0000acd4 --> 调用命令处理函数
    - Step: 0xace4: mov r4, r1 --> 子函数接收污染指针
    - Step: 0xad84: ldr lr, [pc, 0x2c] --> 加载'security'字符串地址
    - Step: 0xad88: stmib sp, {r4, lr} --> 栈上构建污染参数
    - Sink: 0xad8c: bl sym.imp._eval --> 执行未净化系统命令
  Reason: 基于r2证据确认完整传播路径：1) recv接收的数据存入r8（0xc58c）；2) r8作为参数传递给子函数（0xc9d8）；3) 子函数将数据移入r4（0xace4）；4) 与'security'字符串组合后传入_eval（0xad88）；5) _eval执行未净化命令（0xad8c）。攻击者作为认证用户可通过构造恶意数据包注入任意OS命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7500/_R7500v2-V1.0.3.16.img.extracted/squashfs-root/usr/bin/zipnote
  Taint Propagation Path:
    - Source: Command-line argument (argv[i]) loaded at address 0x8c0c
    - Step: ldr r0, [r8, 4]! at 0x8c0c --> Loads argv element into r0
    - Step: bl fcn.00009830 at 0x8c38 --> Passes tainted r0 to function
    - Step: mov r5, r0 at 0x9834 --> Tainted data copied to r5
    - Step: mov r1, r5 at 0x984c --> Tainted data set as strcpy source parameter
    - Sink: bl sym.imp.strcpy at 0x9850 --> Tainted source passed to strcpy()
  Reason: 通过r2逐条验证：1) 0x8c0c的ldr指令加载argv元素到r0；2) 0x8c38的bl指令调用函数并传递r0；3) 函数入口0x9834将参数r0移入r5；4) 0x984c将r5移入strcpy的源参数寄存器r1；5) 0x9850调用strcpy。所有指令与线索完全匹配，污点数据从命令行参数直接流向strcpy且无任何边界检查或净化操作。攻击者作为合法用户可通过控制argv参数触发缓冲区溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: getenv("IPREMOTE") @ 0x15788 --> 环境变量值存入r0
    - Step: mov r3, r0 @ 0x15790 --> 污点值转移到r3
    - Step: bl sym.imp.route_add(r6, 0, r7, r3) @ 0x157a4 --> 污点值作为第四参数传递
  Reason: 验证路径：1) 在0x15788确认getenv("IPREMOTE")调用 2) 后续0x15790的mov r3, r0指令直接传递返回值 3) route_add在0x157a4被调用时，r3作为第四参数且未被修改。攻击者作为已登录用户可控制IPREMOTE环境变量，若route_add存在命令注入漏洞（如拼接系统命令），则可实现RCE。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_WH450AV1BR_WH450A_V1.0.0.18_EN.bin.extracted/squashfs-root/usr/sbin/vconfig
  Taint Propagation Path:
    - Source: argv[1] passed as command-line argument at main function entry (0x0040095c)
    - Step: lw s3, 4(a1) at 0x004009e0 --> Loads argv[1] into s3 register (a1 holds argv pointer)
    - Step: jalr t9 at 0x004010ec (with a2 = s3) --> Calls format function with fixed string 'Unknown command -:%s:-' at 0x40172c and user-controlled s3 as argument
    - Sink: Format function call at 0x004010ec with user-controlled input as format string variable
  Reason: 验证结果：1) 漏洞真实存在（vulnerability=true）: argv[1]直接传递到格式函数%s参数；2) 线索不准确（accuracy=inaccurate）: 关键地址错误（加载点应为0x004009e0非0x00400a30，调用点应为0x004010ec非0x00401124）。证据链：r2反编译显示main函数中：- param_2+4加载到unaff_s3（0x004009e0）- 循环内通过函数指针(**(iStack_68 + -0x7f9c))调用（0x004010ec）- 参数包含固定含%s的字符串和unaff_s3。威胁模型下认证用户完全控制argv[1]，无过滤措施，可注入%n等格式符触发内存写。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7500/_R7500v2-V1.0.3.16.img.extracted/squashfs-root/usr/sbin/firmware_update
  Taint Propagation Path:
    - Source: 命令行选项-2(post_action)参数值
    - Step: 0x9754: str r2, [r3, 0x20] --> 在case 2分支存储参数到全局变量0x1280c
    - Step: 0x92f4: ldr r3, [r3, 0x20] --> 从全局变量0x1280c加载污点数据到r3
    - Step: 0x92f8: mov r0, r3 --> 转移污点数据至system参数寄存器
    - Sink: 0x92fc: bl sym.imp.system --> 污点数据直接传入system()
  Reason: 基于r2证据链验证：1) 0x9754处str指令确认存储到0x1280c全局变量 2) 0x92f4处ldr指令加载该变量 3) 数据经mov传递至r0后直接调用system。攻击者通过命令行参数完全控制输入，且全程无净化操作，构成命令注入漏洞。POC：传递恶意参数如'$(malicious_command)'可执行任意命令。
</finding>
<finding>
  Binary Path: TP_Link/analyzed/_archer_c5v2_us-up-ver3-17-1-P1.bin.extracted/squashfs-root/sbin/hotplug
  Taint Propagation Path:
    - Source: getenv("INTERFACE") at 0x11498 --> char* env_value = getenv("INTERFACE")
    - Step: 0x1149c: subs r4, r0, 0 --> r4 = env_value (tainted data)
    - Step: 0x11580: str r4, [sp+0x10] --> Store tainted data at stack offset sp+0x10
    - Step: 0x11564: mov r0, sp --> Set r0 (arg1) to point to stack structure containing tainted data
    - Sink: 0x11594: bl sym.imp._eval --> Call _eval(r0) with tainted stack structure
  Reason: 证据链完整：1) getenv获取外部可控环境变量；2) 数据经寄存器r4存储到栈sp+0x10；3) 栈指针sp作为参数传递给_eval；4) 栈结构包含未净化的污染数据。攻击者可通过控制INTERFACE环境变量注入恶意数据，最终被_eval执行。POC：设置INTERFACE=恶意代码触发路径。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_XR500-V2.1.0.4.img.extracted/squashfs-root/usr/sbin/ssidsteering
  Taint Propagation Path:
    - Source: bl sym.imp.fgets @ 0x89b4 --> 用户通过-C参数指定配置文件路径，fgets读取配置文件内容到栈缓冲区 (puVar15 - 0x2e0)
    - Step: bl sym.imp.strcpy @ 0x8b00 --> 污点数据复制到栈缓冲区 (puVar15 - 0xe0)
    - Step: bl sym.imp.strcpy @ 0x8b3c --> 污点数据写入全局结构体 (地址存储在0x8d88)
    - Step: ldr r8, [0x00008d88] @ 0x8c30 --> 加载全局结构体地址到r8寄存器
    - Step: mov r1, r8 @ 0x8c94 --> 污点数据地址作为strncpy源参数传递到r1
    - Step: bl sym.imp.strncpy @ 0x8cc8 --> 复制0x10字节污点数据到ioctl参数缓冲区 (puVar15 - 0x78)
    - Sink: bl sym.imp.ioctl @ 0x8cec --> 污点数据传入内核驱动 (request=0x8bea)
  Reason: 1) 配置文件路径通过命令行参数-C完全用户可控；2) fgets读取后经两次strcpy和一次strncpy传播，无长度校验或净化；3) r2验证所有关键指令存在：0x89b4(fgets), 0x8b00/8b3c(strcpy), 0x8c30(ldr), 0x8c94(mov), 0x8cc8(strncpy), 0x8cec(ioctl)；4) 数据流完整：配置文件→栈缓冲区→全局结构体→寄存器→ioctl参数缓冲区→内核。攻击者可通过恶意配置文件注入内核命令。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DWR-118_V1.01b01.bin.extracted/squashfs-root/usr/bin/csmtool
  Taint Propagation Path:
    - Source: fgets(stdin) @ 0x004029a8: lw t9,-sym.imp.fgets(gp); jalr t9; a0=fp+0x28, a1=0x200, a2=**(gp-0x7f70) --> 从标准输入读取512字节到栈缓冲区
    - Step: 0x00402a38: addiu v0, fp, 0x28; 0x00402a3c: move a0, v0; 0x00402a40: addiu a1, zero, 0x20; 0x00402a44: lw t9, -sym.imp.strchr(gp); 0x00402a4c: jalr t9 --> 在输入中定位首个空格，返回指针存v0
    - Step: 0x00402a84: sb zero, (v0) --> 将空格替换为NULL终止符
    - Step: 0x00402a90: addiu v1, v0, 1 --> v1指向空格后的参数字符串起始位置
    - Step: 0x00402a98: addiu a0, v0, 0x48b0; 0x00402a9c: move a1, v1; 0x00402aa0: lw t9, -sym.imp.strcpy(gp); 0x00402aa8: jalr t9 --> 将v1指向的字符串复制到.bss段0x4148b0
    - Sink: strcpy@0x00402aa8: 污点数据写入固定缓冲区0x4148b0(128B)且无长度检查
  Reason: 验证证据链：1) r2确认所有关键指令存在且位置准确；2) 数据流连续：stdin输入→空格定位→参数提取→未净化复制；3) 目标缓冲区128B < 输入上限512B；4) .bss段溢出可覆盖相邻全局变量。POC：构造510字节输入（含空格分隔），空格后>128B内容将溢出覆盖.bss段数据
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-885L_fw_revA_1-13_eu_multi_20170119/_DIR885LA1_FW113b03.bin.extracted/squashfs-root/usr/sbin/eapd
  Taint Propagation Path:
    - Source: recv(*(param_1+0x3fdc), buffer, 0xff0, 0) @ 0xc25c in fcn.0000bad0
    - Step: mov r1, r8 @ 0xc59c in fcn.0000bad0 --> recv buffer passed as arg2 via r8
    - Step: bl fcn.0000aa8c @ 0xc5a0 in fcn.0000bad0 --> Tainted r1 transferred
    - Step: mov r4, r1 @ 0xaa9c in fcn.0000aa8c --> Contaminated param_2 stored in r4
    - Step: str r4, [var_4h] @ 0xab74 in fcn.0000aa8c --> *(puVar3-0x38)=param_2 on stack
    - Step: *(puVar3-0x38) used in command array @ 0xab80 --> [global_str, tainted_param, ...]
    - Sink: bl sym.imp._eval @ 0xab88 in fcn.0000aa8c --> Executing raw command array
  Reason: 逆向分析确认：1) recv接收的buffer通过r8传递至fcn.0000aa8c的param_2；2) 在0xaa9c存入r4后于0xab74存储到栈(puVar3-0x38)；3) 该栈位置被用于构造命令数组[global_str, tainted_param, ...]；4) 最终作为_eval的首参数执行。未发现过滤机制，攻击者可通过注入分号/反引号执行任意命令。POC：发送含';reboot;'的有效载荷即可触发设备重启。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6700-V1.0.1.36_10.0.40/fw/_R6700-V1.0.1.36_10.0.40.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: acosNvramConfig_get("new_firmware_version") @0x962c → mov r1, r0
    - Step: 0x9634: mov r0, r4 → 目标缓冲区=sp+0x3c (r4)
    - Step: 0x9638: bl sym.imp.sprintf → 缓冲区大小=0x1c (0x9610)
    - Sink: sprintf栈溢出 @0x9638 (缓冲区范围: sp+0x3c 到 sp+0x58)
  Reason: Radare2证据：1) acosNvramConfig_get返回值直接作为sprintf格式字符串 2) 目标缓冲区实际位于sp+0x3c 3) 缓冲区大小固定0x1c字节。漏洞存在依据：缓冲区溢出已验证，攻击者可通过超长NVRAM值覆盖栈数据。但无法精确验证返回地址位置：afv命令无输出，栈布局证据不足。偏差说明：线索称缓冲区在sp+0x38，实际为sp+0x3c。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/usr/sbin/timesync
  Taint Propagation Path:
    - Source: Command-line argument argv[1] passed to main function (param_2[1])
    - Step: sym.imp.sprintf(puVar14 -0x114, *0x8e64, param_2[1], iVar11) --> Directly formats user-controlled argv[1] into stack buffer without sanitization
    - Sink: uVar4 = sym.imp.system(puVar14 -0x114) --> Executes unsanitized buffer containing argv[1]
  Reason: Radare2反编译证据显示：1) argv[1]作为param_2[1]传入；2) sprintf将param_2[1]直接拼接到栈缓冲区(puVar14-0x114)；3) 同一缓冲区立即传递给system()执行。路径位于条件分支((iVar10==0||iVar10==2) && gethostbyname(iVar11)!=0)内，攻击者可通过控制iVar10/iVar11触发。POC：构造恶意argv[1]包含命令分隔符(如'; rm -rf /')，当条件满足时将执行任意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: bl sym.imp.fgets @0x8918 (输入数据存储到[sp+0x1c0])
    - Step: 0x88d4: add r7, sp, 0x180 --> 准备sscanf输出缓冲区
    - Step: 0x88f0: bl sym.imp.sscanf (格式@0xa95c="%s %s"; 第二输出存r7=[sp+0x180]) --> 解析用户输入
    - Step: 0x8900: bl sym.imp.sprintf (格式@0xa964="wl sta_info %s > /dev/kmsg"; 参数r2=r7) --> 拼接命令到[sp]
    - Sink: 0x8908: bl sym.imp.system (参数r0=sp) --> 执行未过滤命令
  Reason: Radare2证据链证实：1) fgets输入经sscanf解析后存入r7（0x88d4建立）；2) r7直接用于sprintf命令拼接（0x8900的'mov r2, r7'）；3) 格式化后的sp缓冲区直接传入system（0x8908）。攻击者可通过控制fgets输入的第二参数注入命令（如输入'a;rm -rf /'），经sscanf存入r7后构造恶意命令。关键偏移差异：实际存储位置[sp+0x180]非线索所述[sp-100]，但核心传播逻辑成立且无净化措施。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R9000/firmware/squashfs-root/usr/sbin/net-wall
  Taint Propagation Path:
    - Source: Hardcoded string '/tmp/netwall-rules' at address 0x24560
    - Step: Function fcn.00013df8 at 0x13df8: iVar1 = sym.imp.fopen(0x24560, "w") --> Opens file in write mode without O_EXCL lock
    - Step: sym.imp.fprintf(iVar1, 0xadb4 | 0x10000, *puVar5) at function fcn.00013df8 --> Writes configuration data to file handle
    - Step: sym.imp.fwrite(0xb2cc | 0x10000, 1, 0x3d, iVar1) at function fcn.00013df8 --> Writes fixed data block to file
    - Sink: Multiple file write operations (fprintf/fwrite) on handle iVar1 throughout function fcn.00013df8
  Reason: 证据链完整：1. r2确认0x24560处存在字符串'/tmp/netwall-rules'；2. 函数fcn.00013df8反编译显示fopen调用使用该字符串和"w"模式；3. 同一文件句柄iVar1被传递至多个fprintf/fwrite操作；4. 无净化操作或安全检查。攻击者可通过符号链接劫持文件写入，覆盖任意文件内容。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ipv6_lan_length_old') @ 0x19e5c
    - Step: ldr r0, str.ipv6_lan_length_old @ 0x19e5c --> 加载环境变量名
    - Step: bl sym.imp.acosNvramConfig_get @ 0x19e60 --> 污点值存入r0
    - Step: str r0, [sp] @ 0x19e70 --> 污点值压栈作为sprintf参数
    - Step: sprintf(auStack, "ifconfig %s del %s/%s", r7, r6, [sp]) @ 0x19e78 --> 污点值直接嵌入命令字符串
    - Step: mov r0, r4 @ 0x19e7c --> 构造的命令字符串移至r0
    - Sink: bl sym.imp.system @ 0x19e80 --> 执行含污点数据的系统命令
  Reason: 基于r2反汇编证据：1) 污点源acosNvramConfig_get返回的环境变量值未经任何净化 2) 通过栈位置[sp]直接传递给sprintf格式化函数 3) 最终构造的完整命令字符串传递给system执行。攻击者作为合法用户可控制'ipv6_lan_length_old'值（如注入'; rm -rf /'），实现命令注入。POC：设置ipv6_lan_length_old='eth0; rm -rf /'触发恶意命令执行。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/sbin/wwan
  Taint Propagation Path:
    - Source: NVRAM variable 'wwan_runtime_model' accessed via acosNvramConfig_get @ 0x970c
    - Step: ldr r0, str.wwan_runtime_model ; [0xd620:4]=0x6e617777 --> Loads variable name into r0 @ 0x970c
    - Step: bl sym.imp.acosNvramConfig_get --> Retrieves tainted value to r0 @ 0x9710
    - Step: mov r1, r0 ; const char *src --> Moves tainted data to strcpy source argument @ 0x9714
    - Step: mov r0, sp ; char *dest --> Sets stack pointer as destination buffer @ 0x9718
    - Sink: bl sym.imp.strcpy --> Tainted data passed to strcpy without length check @ 0x971c
  Reason: 基于r2反汇编证据：1) 存在明确的NVRAM变量名引用(0x970c)；2) acosNvramConfig_get返回值直接作为strcpy的src参数(0x9714)；3) strcpy目标为栈缓冲区(0x9718)；4) 路径中无安全检查指令。攻击者通过合法凭据设置NVRAM值即可触发栈溢出。POC：设置超长'wwan_runtime_model'值触发strcpy溢出。
</finding>
<finding>
  Binary Path: d-link/analyzed/_DWR-118_V1.01b01.bin.extracted/squashfs-root/usr/bin/pptp-ondemand
  Taint Propagation Path:
    - Source: argv[4] from command-line arguments in main function @0x401b24
    - Step: 0x00401e3c: addiu v0, v0, 0x10 ; 0x00401e40: lw v1, (v0) --> Load argv[4] into v1
    - Step: 0x00401e64: snprintf(auStack_20, 0x10, "pptpc-start %s", v1) --> Format user-controlled argv[4] into stack buffer
    - Sink: 0x00401e80: system(auStack_20) --> Execute tainted buffer without sanitization
  Reason: Radare2证实：1) argv[4]通过*(argv+0x10)访问；2) snprintf@0x401e64直接使用argv[4]作为源参数；3) system@0x401e80执行snprintf输出的未净化缓冲区。攻击者控制argv[4]可注入任意命令（如';rm -rf /'），POC：./program arg1 arg2 arg3 ';malicious_command'
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R9000/firmware/squashfs-root/usr/sbin/spectraltool
  Taint Propagation Path:
    - Source: recvfrom() at 0x9a14 (mov r1, r5 @0x99fc) --> Receives UDP raw data into buffer pointed by r5
    - Step: 0x00009a8c: ldrh r2, [r5, 0x6b] --> Loads 2-byte value from offset 0x6b of tainted buffer into r2
    - Sink: 0x00009a98: bl sym.imp.memcpy (r2) --> Tainted length value passed directly to memcpy
  Reason: Radare2验证：1) 0x9a14反汇编确认recvfrom调用(r5作为缓冲区指针)；2) 0x9a8c指令确认为ldrh r2加载偏移0x6b数据；3) 0x9a98确认为memcpy调用且r2作为第三参数。寄存器跟踪显示：r5在0x9a18-0x9a8c无修改(保证缓冲区地址稳定)，r2在0x9a8c-0x9a98无修改(保证污点数据直达sink)。攻击者通过伪造UDP包控制偏移0x6b的2字节值，直接控制memcpy长度参数且无边界检查，构成内存破坏漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7800/firmware/squashfs-root/usr/sbin/ubinize
  Taint Propagation Path:
    - Source: User-controlled structure arguments (arg1 in r0, arg2 in r1)
    - Step: 0xa6ac: ldr r5, [r1, 0x10] --> 从用户控制的arg2+0x10加载污染数据到r5
    - Step: 0xa6b8: ldr r6, [r0] --> 从用户控制的arg1加载污染数据到r6
    - Step: 0xa6c8: bl sym.imp.malloc(r6) --> 使用污染值r6分配堆缓冲区
    - Step: 0xa738: mov r2, r5 --> 将污染值r5转移到read的size参数寄存器r2
    - Sink: 0xa73c: bl sym.imp.read(fildes, r7, r2) --> 使用污染值r5作为读取长度
  Reason: Radare2验证确认：1) arg1(r0)和arg2(r1)在函数入口被保留(r4=arg1, r8=arg2)；2) r6=*arg1直接用于malloc(0xa6b8-0xa6c8)；3) r5=arg2[0x10]直接用于read长度(0xa6ac-0xa738-0xa73c)。攻击者通过控制父函数参数可分别操纵r5(read长度)和r6(malloc大小)，当r5>r6时导致堆溢出。证据链完整无净化操作。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: sym.imp.fgets(r4, 0x80, r8) @0x8998 --> 从'/tmp/debug_sta_info'读取数据到栈地址[sp+0x1c0]
    - Step: sym.imp.sscanf(r4, "%s %s", sl, r7) @0x8974 --> 解析第二字符串存入r7指向的[sp+0x180]
    - Step: sym.imp.sprintf(sp, "wl -i eth2 sta_info %s > /dev/kmsg", r7) @0x8984 --> 使用污点数据格式化命令字符串
    - Sink: sym.imp.system(sp) @0x898c --> 执行污染的命令缓冲区
  Reason: 证据链完整：1) fgets读取外部可控文件（反编译确认路径）2) sscanf提取第二字段到栈变量（pd指令验证参数传递）3) sprintf直接拼接未过滤数据（字符串常量0xaa08确认命令格式）4) system执行动态命令（调用指令明确）。偏移差异因函数栈帧基准不同，但数据流路径经交叉验证可复现。POC：向/tmp/debug_sta_info写入'valid_data;malicious_command'，第二字段注入命令将被执行。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/bin/phddns
  Taint Propagation Path:
    - Source: Command-line arguments (argv) stored via str r1, [var_14h] @ 0x11400 in fcn.000113f0
    - Step: 0x0001199c: bl sym.imp.sprintf(r0, "su %s -c \"", r2) --> Formats base command with tainted param_4+0x117 (r2 loaded @ 0x11984)
    - Step: 0x00011a68: bl sym.imp.sprintf(r0, "%s %s", r0, ip) --> Appends user-controlled argv[i] (ip loaded @ 0x11a40 from argv array)
    - Step: 0x00011ac4: bl sym.imp.sprintf(r0, "%s \"", r0) --> Finalizes command string
    - Sink: 0x00011ad8: bl sym.imp.system(r0) --> Executes compound command with unvalidated input
  Reason: 基于r2实证：1) 三次sprintf目标地址均为r0=var_400h-0x10（pxw验证物理地址一致） 2) argv[i]通过指针链[var_41ch]加载（0x11a38） 3) 缓冲区内容连续构建（pdg显示auStack_414复用） 4) system参数与sprintf目标相同（0x11ad8前指令：mov r0, r2）。威胁模型下攻击者完全控制argv[i]可注入命令分隔符。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7800/firmware/squashfs-root/usr/sbin/phddns
  Taint Propagation Path:
    - Source: Command-line argument argv[1] in main function fcn.00008e88
    - Step: 0x8fa0: ldr r1, [r4, 4] --> Loads argv[1] address into r1
    - Step: 0x8fa4: bl sym.imp.strcpy --> Copies tainted data to global buffer at (*0x9018)+0x110
    - Sink: strcpy() overflow at 0x8fa4
  Reason: 通过r2验证：1) 0x8fa0指令明确加载argv[1]到r1；2) 反编译显示strcpy目标为全局指针(*0x9018)+0x110的固定缓冲区；3) 无长度检查指令（如strlen/strncpy）。攻击者通过argv[1]注入超长数据可触发溢出，符合威胁模型中已认证用户场景。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7800/firmware/squashfs-root/usr/sbin/ubinize
  Taint Propagation Path:
    - Source: argv parameter from command line (optarg)
    - Step: ldr r0, [r4] @ 0x9064 --> 加载optarg到r0（r4指向optarg）
    - Step: str r3, [r5, 4] @ 0x9084 --> 将r0的值经r3存储到全局结构体(*0x9d4c)[1]（r5指向结构体基址）
    - Step: ldr r4, [0x9d4c] @ 0x92ac --> 加载全局结构体基址到r4
    - Step: ldr r0, [r4, 4] @ 0x92b8 --> 从结构体偏移4加载污染数据到r0
    - Sink: bl sym.imp.remove @ 0x92bc --> 以r0为参数调用remove()删除文件
  Reason: 证据链完整：1) 0x9064确认加载命令行参数optarg；2) 0x9084将参数存入全局结构体；3) 0x92b8从同一结构体位置加载值到r0；4) 0x92bc以r0为参数调用remove。全程无净化操作，攻击者通过-o参数可注入任意文件路径导致删除。POC：./program -o /etc/passwd
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7800/firmware/squashfs-root/usr/sbin/phddns
  Taint Propagation Path:
    - Source: Command-line argument argv[4] in main function fcn.00008e88
    - Step: 0x00008fc0: ldr r0, [0x9044] --> Loads global buffer address from 0x9044 to r0
    - Step: 0x00008fc4: ldr r1, [r4, #0x10] --> Loads argv[4] (r4 is argv) to r1
    - Sink: 0x00008fc8: bl sym.imp.strcpy --> Copies tainted argv[4] to fixed buffer
  Reason: 基于r2反汇编证据：1) argv[4]在0x8fc4通过[r4+0x10]加载到r1（r4=argv）2) 全局缓冲地址在0x8fc0通过*0x9044加载到r0 3) strcpy在0x8fc8直接使用两者作为参数。无长度检查或净化操作，攻击者控制argv[4]可触发确定性的缓冲区溢出。地址偏移因二进制差异导致，但数据流逻辑一致。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_R7900-V1.0.1.26_10.0.23.chk.extracted/squashfs-root/usr/sbin/bzip2
  Taint Propagation Path:
    - Source: argv element (arg1) passed to function at 0x0000aa88 via r0 register
    - Step: 0x0000ab14: bl fcn.00008e38(r0, r1) --> Copies argv element from r1 to memory at *0xaf78 via strncpy
    - Step: 0x0000ad78: ldr r0, [0x0000af78] --> Loads tainted path string from contaminated memory
    - Step: 0x0000ad7c: bl sym.imp.fopen64(r0, r1) --> Direct file access with user-controlled path
  Reason: Radare2反汇编证实完整传播链：1) 函数0xaa88入口r0(argv元素)存于r4；2) 0xab14调用fcn.00008e38(*0xaf78, r4)执行strncpy复制污染数据；3) 0xad78加载*0xaf78污染数据到r0；4) 0xad7c调用fopen64。关键证据：strncpy无净化操作(0x8e80-0x8e94)，且fopen直接使用污染数据。攻击者可通过argv注入路径遍历payload(如../)访问任意文件。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-885L_fw_revA_1-13_eu_multi_20170119/_DIR885LA1_FW113b03.bin.extracted/squashfs-root/usr/sbin/iwconfig
  Taint Propagation Path:
    - Source: argv[1] passed as param_2 (r1) to function at 0xa350
    - Step: 0xa360: str r1, [sp, var_39ch] --> Stores tainted argv[1] to stack (var_39ch)
    - Step: 0xa37c: bl fcn.00009200 --> Calls function at 0x9200 with tainted data (r1 = stack value from var_39ch)
    - Step: 0x9200 (at 0x924c): bl fcn.00008e98 --> Passes tainted r1 (argv[1]) as second parameter to subcall
    - Step: 0x8e98 (at 0x8ec8): strncpy(r0, r1, 0x10) --> Copies 16 bytes from tainted r1 (argv[1]) to local buffer
    - Sink: 0x8edc: ioctl(r0, r1, r2) --> Passes local buffer (containing tainted data) as third argument via r2
  Reason: 基于r2反汇编证据：1) 函数fcn.0000a350在0xa360处将argv[1]存储到栈变量；2) 该值在0xa37c作为参数传递给fcn.00009200；3) fcn.00009200在0x924c调用fcn.00008e98时传递污点数据；4) fcn.00008e98在0x8ec8用strncpy复制污点数据到缓冲区；5) 同一函数在0x8edc将缓冲区地址传递给ioctl。strncpy限制16字节但未显式添加空字节终止，且ioctl的缓冲区参数直接包含用户可控数据。攻击者作为合法用户可通过控制argv[1]构造特定数据触发驱动级漏洞。
</finding>
<finding>
  Binary Path: Tenda/analyzed/FH1201/squashfs-root/bin/eapd
  Taint Propagation Path:
    - Source: nvram_get('ses_interface') via eapd_safe_get_conf @ 0x407a54-0x407a60 --> 写入栈缓冲区sp+0x1c
    - Step: 0x407a5c: jalr t9 (call eapd_safe_get_conf) --> 参数a0=sp+0x1c接收NVRAM值
    - Step: 0x407abc: move a0, s1 (s1=sp+0x1c) --> 设置wl_probe参数
    - Sink: wl_probe @ 0x407ab8: jalr t9 --> 外部函数处理受控数据
  Reason: 证据链确认：1) eapd_safe_get_conf内部snprintf将NVRAM值写入sp+0x1c（r2验证地址0x405794）；2) 该缓冲区直接作为a0参数传递至wl_probe（0x407abc指令证据）；3) wl_probe为外部函数（ii验证）。威胁模型下攻击者可通过NVRAM控制数据，路径中无净化操作。线索错误：acStack_94应为sp+0x1c（偏移0x1c非0x94）。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7500/_R7500v2-V1.0.3.16.img.extracted/squashfs-root/usr/sbin/firmware_update
  Taint Propagation Path:
    - Source: 命令行选项-0参数值（如：./firmware_update -0 'attacker_controlled'）
    - Step: 0x96e0: ldr r2, [argv] --> 加载命令行参数数组基地址
    - Step: 0x96e4: add r3, r2, r3 --> 计算当前参数指针
    - Step: 0x96e8: ldr r2, [r3] --> 加载-0选项参数值到r2
    - Step: 0x96f4: str r2, [r3, 0x18] @ r3=0x127ec --> 存储参数值到全局结构体偏移0x18处（0x12804）
    - Step: 0x91e0: ldr r3, [r3, 0x18] @ r3=0x127ec --> 从相同全局地址加载参数值到r3
    - Step: 0x91e4: mov r0, r3 --> 将污点数据移至system参数寄存器r0
    - Sink: 0x91e8: bl sym.imp.system --> 执行system(r0)
  Reason: 基于r2证据链验证：1) 攻击者通过-0选项完全控制参数值（见0x96e8加载指令）; 2) 污点数据经全局结构体（0x127ec+0x18）直接传播至system参数寄存器（0x91e4 mov r0,r3）; 3) 路径中无任何过滤或检查指令。POC：执行`./firmware_update -0 ';malicious_command;'`将触发命令注入。威胁模型成立（攻击者拥有合法凭证）。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/sbin/rdisc6
  Taint Propagation Path:
    - Source: recvmsg()接收网络数据（函数fcn.0000a414 @ 0xa56c: bl sym.imp.recvmsg）
    - Step: 0xab60: bl fcn.00009e04(r4) --> 传递结构体指针到callee
    - Step: 0x9e0c: ldr r4, [r0, 8] --> 从结构体偏移8加载污染数据到r4
    - Step: 0xa1a4: sprintf(r8, 0xbfe7, r2, r3, r5, r4) --> 污染数据(r4)作为preferred_lft格式化到命令字符串
    - Sink: 0xa1ac: bl system(r8) --> 执行含污染数据的命令
  Reason: 基于r2证据链：1) recvmsg()在0xa56c接收外部数据存入栈结构体；2) 结构体指针通过r4在0xab60传递给fcn.00009e04；3) fcn.00009e04在0x9e0c处从结构体偏移8加载关键字段到r4；4) r4在0xa1a4作为sprintf参数（格式字符串@0xbfe7）拼接到命令；5) 最终在0xa1ac调用system执行该命令。全程无净化操作，攻击者可通过网络数据控制preferred_lft值注入恶意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_AC1450-V1.0.0.36_10.0.17.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: fopen("/tmp/ppp/l2tpSrvIp", "r") @ 0xe4d0
    - Step: mov r0, r8 @0xe4f0 --> 设置fgets目标缓冲区
      bl sym.imp.fgets @0xe4f4 --> 文件内容读入r8指向栈区
    - Step: ldr r1, str.route_del__s_gw__s @0xe518 --> 加载格式化字符串
      mov r2, r8 @0xe520 --> 污点数据作为sprintf第二参数
      bl sym.imp.sprintf @0xe528 --> 生成命令字符串
    - Sink: mov r0, r7 @0xe52c --> 传递格式化结果
      bl sym.imp.system @0xe530 --> 执行未净化命令
  Reason: 基于r2反汇编证据：1) 攻击者可控文件/tmp/ppp/l2tpSrvIp内容通过fgets(0xe4f4)读入栈缓冲区(r8) 2) 该缓冲区直接作为sprintf(0xe528)的第二个参数(%s) 3) 生成命令字符串经system(0xe530)执行。传播路径0xe4d0→0xe4f4→0xe528→0xe530完整存在，中间无过滤操作。POC：向/tmp/ppp/l2tpSrvIp写入';malicious_command'可注入任意命令。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root/bin/phddns
  Taint Propagation Path:
    - Source: fcn.0000b0c8 @0xb0c8 accesses argv[3] via *(*(puVar4 + -0x14) + 0xc) --> External input captured
    - Step: str r1, [var_24h] @0x10b98 --> Stores tainted argv[3] on stack (confirmed by pd command)
    - Step: ldr r1, [var_24h] @0x10e24 --> Loads tainted data for conditional use (confirmed by pd command)
    - Step: bl sym.imp.doSystemCmd @0x10e28 --> Passes tainted data via r1 when *piVar6 !=0 (confirmed in fcn.00010b80 pseudocode)
    - Sink: bl sym.imp.doSystemCmd @0x10e54 --> Executes command with attacker-controlled argument (confirmed by pd command)
  Reason: 完整的污点传播路径证据：1) argv[3] 在 fcn.0000b0c8 被访问（pdg 验证）；2) 数据通过栈存储/加载（0x10b98/0x10e24 指令验证）；3) 直接传递至 doSystemCmd sink（0x10e28/0x10e54 指令验证）；4) 伪代码显示无过滤操作；5) 条件分支 (*piVar6 !=0) 在 fcn.00010b80 中控制执行流（反编译验证）。POC：合法用户通过控制 argv[3] 可执行任意命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: iVar3 = sym.imp.fgets(puVar7 - 0xe4, 0x80, iVar1); // 从文件读取内容到栈缓冲区 [sp-0xe4]
    - Step: sym.imp.sscanf(puVar7 - 0xe4, *0x8da8, ..., puVar7 - 100); // 解析第二个字符串到 [sp-100]
    - Step: sym.imp.sprintf(puVar7 - 0x1e4, *0x8dd0, puVar7 - 100); // 拼接命令到 [sp-0x1e4]
    - Sink: sym.imp.system(puVar7 - 0x1e4); // 执行未过滤的命令
  Reason: 反编译代码显示：1) fgets 读取外部可控文件（*0x8da0）；2) sscanf 用格式 *0x8da8 解析出第二个参数直接存储至 [sp-100]；3) sprintf 使用 *0x8dd0 格式（含 %s 占位符）将污点数据拼入命令；4) system 直接执行该命令。攻击者可通过篡改文件内容注入任意命令，且无过滤证据。POC：创建恶意文件使第二个字段包含 '; rm -rf /'，触发命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: acosNvramConfig_get('ver_check_ftp_username') @0xa154 (ldr r0, 0xc154; bl sym.imp.acosNvramConfig_get) --> NVRAM value loaded to r0
    - Step: mov sb, r0 @0xa15c --> Tainted value stored in sb register
    - Step: mov r3, sb @0xa194 --> Tainted value moved to sprintf argument
    - Step: sprintf(r6, 'rm -f %s;ftpc -u %s -p %s...', ..., r3) @0xa1b8 (bl sym.imp.sprintf) --> Direct interpolation into command string with tainted data
    - Sink: system(r6) @0xa1c0 (mov r0, r6; bl sym.imp.system) --> Command execution with attacker-controlled data
  Reason: 证据链证明：1) 'ver_check_ftp_username'通过NVRAM获取且未净化（0xa154反汇编）2) 该值经寄存器传递至sprintf参数r3（0xa194指令）3) 危险格式串含多个%s占位符（0xc1b4内存数据）4) 构造的命令缓冲区直接传入system（0xa1bc指令）。POC：设置NVRAM值如';rm -rf /'可注入命令。偏差：实际源变量/命令格式与线索不同，但漏洞本质相同。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R8000-V1.0.4.4_1.1.42/fw/_R8000-V1.0.4.4_1.1.42.chk.extracted/squashfs-root/sbin/acos_service
  Taint Propagation Path:
    - Source: fopen("/tmp/ppp/l2tpSrvIp", "r") at 0x10198 --> File opened for reading
    - Step: 0x101b4: bl sym.imp.fgets(r0=r8, r1=0x14, r2=r4) --> File content read into buffer @r8 (max 20 bytes)
    - Step: 0x101d4: bl sym.imp.acosNvramConfig_get(r0=str."l2tp_gateway_ip") --> Tainted nvram value obtained and stored in r0
    - Step: 0x101dc: mov r3, r0 --> Tainted nvram value moved to r3 for sprintf
    - Step: 0x101e0: mov r2, r8 --> Tainted buffer (file content) moved to r2 for sprintf
    - Step: 0x101e8: bl sym.imp.sprintf(r0=r7, r1=str."route del %s gw %s", r2=r8, r3=r0) --> Tainted data (file content and nvram value) inserted into command format
    - Sink: 0x101f0: bl sym.imp.system(r0=r7) --> Command with tainted data executed
  Reason: 完整路径经r2验证：1) 文件内容通过fgets(0x101b4)读入r8；2) nvram值通过acosNvramConfig_get(0x101d4)存入r0；3) 两者分别通过mov指令传入r2/r3(0x101e0/0x101dc)；4) 直接用于sprintf构造命令(0x101e8)；5) 结果缓冲区r7直接传入system(0x101f0)。关键证据：a) 格式字符串"route del %s gw %s"在0x24518被引用；b) 无过滤操作（仅IP格式验证不防命令注入）；c) 攻击者可控制文件内容（最大20字节）注入分隔符（如';'）。POC：写入'/tmp/ppp/l2tpSrvIp'内容为";恶意命令"即可在system调用时执行。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: ldr r0, str.wan_gateway; bl sym.imp.acosNvramConfig_get @0x930c-0x9310 --> 获取 NVRAM 值 'wan_gateway' 到 r0
    - Step: mov r2, r0 @0x9318 --> 污染数据从 r0 移至 sprintf 的格式参数寄存器 r2
    - Step: ldr r1, str.ping__c_4__s_____tmp_ping.txt; bl sym.imp.sprintf @0x9314-0x9320 --> 执行 sprintf(buffer, "ping -c 4 %s >> /tmp/ping.txt", r2)，r2 直接插入命令字符串
    - Step: mov r0, r8 @0x9324 --> 完整命令字符串（含污染数据）移至 system 参数寄存器 r0
    - Sink: bl sym.imp.system @0x9328 --> 污染命令字符串通过 system(r0) 执行
  Reason: 反汇编证实：1) 'wan_gateway' 值通过 r2 直接注入 sprintf 的 %s 占位符；2) 生成的命令字符串无任何净化直接传入 system。攻击者可修改 'wan_gateway' 注入任意命令（如 'wan_gateway; rm -rf /'），POC：修改 NVRAM 后触发该代码路径即可实现 RCE。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/timesync
  Taint Propagation Path:
    - Source: Command-line argument argv[1] passed to main function (address: 0x8a70: mov r4, r1)
    - Step: 0x00008bdc: ldr r2, [r7, 4] --> Loads argv[1] into r2 (r7 points to argv array, [r7+4]=argv[1])
    - Step: 0x00008be4: bl sym.imp.sprintf --> Formats command: sprintf(string, "%s -p 123 -c 3 -i 5 -s -h %s", r2(argv[1]), r3(internal data))
    - Sink: 0x00008bec: bl sym.imp.system --> Executes tainted command: system(string)
  Reason: 证据链完整：1. main函数0x8a70确认argv来源；2. 0x8bdc直接加载argv[1]到r2；3. sprintf使用r2作为首个格式化参数（无过滤）；4. system立即执行生成的命令。POC：攻击者可通过argv[1]注入命令（如';malicious_command'），因拼接后形成完整shell命令。关键证据：r2未净化直接进入格式化字符串，且sprintf与system连续调用无干预。
</finding>
<finding>
  Binary Path: Tenda/analyzed/FH1206/squashfs-root/bin/udhcpd
  Taint Propagation Path:
    - Source: Function parameter (a0) in sym.read_leases
    - Step: 0x00402464: move s4, a0   --> Save external input to s4 register
    - Step: 0x00402574: move a1, s4   --> Load tainted data into printf format argument (a1)
    - Sink: 0x00402584: jalr t9 (call sym.imp.printf) --> Vulnerable printf call with tainted a1
  Reason: Radare2证据确认完整传播链：1) 函数头显示a0为参数 2) 0x402464指令将a0移入s4 3) 0x402574指令将s4移入printf的格式字符串参数a1 4) 0x402584调用printf时a0为静态字符串(0x4062e0)，a1为污染数据 5) 路径中无过滤指令。攻击者可通过控制a0参数触发格式化字符串漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6400v2-V1.0.2.46_1.0.36/fw/_R6400v2-V1.0.2.46_1.0.36.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: recvmsg() at 0x8bb0 receives data into param_2 buffer
    - Step: bl fcn.0000952c @0xa0bc [mov r5, r1] --> Passes tainted buffer pointer (param_2)
    - Step: puVar7 = pcVar8 + 0x10 [*(puVar19 + -0x24) = *puVar7] --> Calculates pointer to IPv6 address field and copies to stack
    - Step: sym.imp.inet_ntop(10, puVar19 + -0x24, ...) --> Converts binary IPv6 address to string
    - Step: sym.imp.create_ipv6_addr(..., puVar19 + -0x244) --> Processes tainted string
    - Step: sym.imp.sprintf(puVar19 + -0x554, format, puVar19 + -0x244) --> Embeds processed data in command
    - Sink: sym.imp.system(puVar19 + -0x554) --> Executes command containing tainted data
  Reason: 完整证据链：1) recvmsg@0x8bb0接收外部数据 2) fcn.00009ea4@0xa0bc调用fcn.0000952c传递污点缓冲区 3) 反编译显示pcVar8+0x10计算地址并复制IPv6字段(puVar19 + -0x24) 4) inet_ntop直接转换未经验证的二进制地址 5) create_ipv6_addr处理转换后的字符串 6) sprintf将结果嵌入命令 7) system执行命令。POC：攻击者可构造恶意IPv6地址（如'; rm -rf / #'）通过recvmsg注入，经inet_ntop/create_ipv6_addr转换后形成危险命令。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/sbin/updateleases
  Taint Propagation Path:
    - Source: fread(auStack_3c4, 0x5c, 1, file_ptr) in fcn.00008bcc (0x8bcc) --> 从文件读取污染数据
    - Step: sprintf(auStack_38, "%02x:%02x:%02x:%02x:%02x:%02x", ...) in fcn.00008bcc (0x8bcc) --> 格式化为MAC字符串
    - Step: call fcn.0000a1c4(..., auStack_38) in fcn.00008bcc (0x8bcc) --> 传递污染字符串
    - Step: snprintf(auStack_208, 0x1ff, "%s %s", tainted_str) in fcn.0000a1c4 (0xa204) --> 二次格式化
    - Sink: send(socket, tainted_buffer, len, flags) in fcn.00009a18 (0x9a90) --> 网络发送敏感数据
  Reason: 基于r2证据验证：1) 0x8bcc处fread读取文件数据到栈缓冲区(auStack_3c4) 2) 同函数内sprintf格式化MAC地址到auStack_38 3) 调用fcn.0000a1c4传递格式化字符串 4) 0xa204处snprintf进行二次格式化 5) 0x9a90处send发送污点数据。文件路径和内容完全可控，传播路径无净化操作，攻击者可构造恶意文件泄露MAC/IP等租约信息。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/arp_check
  Taint Propagation Path:
    - Source: fgets() reads tainted data from /proc/net/wandev into buffer at r5 (address: 0xa9d0)
    - Step: 0xa9d8: mov r2, r5   ; 将污点数据准备为sprintf参数
0xa9dc: ldr r1, str.echo____s______tmp_wan_detect_log   ; 加载命令格式字符串
0xa9e0: mov r0, r4   ; 设置目标缓冲区
0xa9f0: bl sym.imp.sprintf   ; 将污点数据(r5)格式化到r4 --> Tainted data embedded into command string
    - Sink: 0xa9f4: mov r0, r4   ; 将格式化后的命令传入system
0xa9f8: bl sym.imp.system   ; 执行未验证的命令 --> Command injection via unvalidated input
  Reason: 通过r2反汇编确认完整传播链：1) fgets读取用户可控的/proc/net/wandev数据到r5(0xa9cc-0xa9d0)；2) r5直接作为sprintf的输入参数格式化到r4(0xa9d8-0xa9f0)；3) r4未经任何过滤传入system执行(0xa9f4-0xa9f8)。攻击者可向/proc/net/wandev写入'\nid>/tmp/pwn\n'等数据，在sprintf生成的命令中注入新指令。POC：echo -e '\nid>/tmp/pwn\n' > /proc/net/wandev 将执行id命令。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: sym.imp.fopen("/tmp/debug_sta_info", "r") @0x88bc
    - Step: sym.imp.fgets([sp-0xe4], 0x80, stream) @0x8918 --> 从文件读取污染数据到栈缓冲区
    - Step: sym.imp.sscanf([sp-0xe4], "%s %s", [sp-0x24], [sp-0x64]) @0x88f0 --> 解析第二个%s到偏移-100(0x64)
    - Step: sym.imp.sprintf([sp-0x1e4], "wl sta_info %s > /dev/kmsg", [sp-0x64]) @0x8900 --> 拼接未过滤数据到命令缓冲区
    - Sink: sym.imp.system([sp-0x1e4]) @0x8908 --> 执行污染命令
  Reason: 基于r2验证：1) 文件路径*0x8da0="/tmp/debug_sta_info"；2) sscanf格式串@0xa95c="%s %s"；3) sprintf格式串@0xa964="wl sta_info %s > /dev/kmsg"；4) 栈结构显示[sp-0x64]对应偏移-100。攻击者写入文件可注入命令（如';rm -rf /'），经sscanf解析后直接拼接至system()执行，全程无过滤。
</finding>
<finding>
  Binary Path: Tenda/analyzed/_US_WH450AV1BR_WH450A_V1.0.0.18_EN.bin.extracted/squashfs-root/usr/sbin/vconfig
  Taint Propagation Path:
    - Source: argv[2] passed to main function at 0x0040095c (uVar8 = *(param_2 + 8))
    - Step: uVar3 = (**(iVar11 + -0x7fc4))(uVar8) --> Calls strlen() at 0x00401370 to get argv[2] length at 0x00400a4c
    - Step: (**(iVar11 + -0x7f74))(&uStack_5c, uVar8) --> Calls strcpy() at 0x004012b0 to copy argv[2] to 4-byte stack buffer uStack_5c
    - Sink: Stack buffer overflow when input length≥4 (copies 5-16 bytes), overwriting adjacent stack variables from sp+0x5c to sp+0x6c
  Reason: Radare2证据链确认：1) argv[2]用户输入通过strcpy直接复制到固定栈缓冲区；2) 栈布局显示uStack_5c仅4字节；3) 长度检查(0xf < uVar3)不阻止4-15字节输入；4) strcpy无边界检查导致溢出。攻击者可通过合法命令注入4-15字节覆盖栈变量。POC：执行程序 './binary set_name_type AAAA' 即可触发4字节溢出。
</finding>
<finding>
  Binary Path: TP_Link/analyzed/Archer_C20_V1_151120/_ArcherC20v1_0.9.1_2.1_up_boot_151120_2015-11-20_09.54.33.bin.extracted/squashfs-root/usr/sbin/dhcp6c
  Taint Propagation Path:
    - Source: Command-line argument (ppuVar14[1]) in main function (0x402bbc)
    - Step: 0x402ba4: jalr t9 [call to sprintf] with args: a0=obj.info_path, a1="/var/run/dhcp6c-%s.info"@0x423488, a2=ppuVar14[1] --> Tainted ARGV element used in formatted string
    - Step: 0x402bc0: jalr t9 [call to fopen] with args: a0=obj.info_path, a1="w"@0x423a58 --> Tainted file path passed to fopen()
    - Sink: 0x402bc0: fopen(obj.info_path, "w") with write mode
  Reason: 基于r2证据：1. 汇编显示ppuVar14[1]直接作为a2参数传递给格式化函数（0x402ba4）；2. obj.info_path作为a0参数直接传递给fopen（0x402bc0）；3. 0x423a58处验证存在"w"字符串；4. 反编译确认全局变量obj.info_path在两者间无修改。攻击者通过控制命令行参数可注入路径遍历序列覆盖任意文件。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7800/firmware/squashfs-root/usr/sbin/phddns
  Taint Propagation Path:
    - Source: Command-line argument argv[2] in main function fcn.00008e88 (r4 initialized at 0x8e94: mov r4, r1)
    - Step: 0x8fa8: ldr r1, [r4, #8] --> Loads argv[2] pointer to r1
    - Step: 0x8fac: ldr r0, [0x903c] --> Loads global buffer address 0x1752e to r0 (confirmed by pxw @0x903c)
    - Sink: 0x8fb0: bl sym.imp.strcpy --> Copies tainted argv[2] data to fixed buffer @0x1752e
  Reason: Radare2验证证据链：1) pdf @fcn.00008e88显示r4初始化为argv指针；2) pd @0x8fa8证实加载argv[2]；3) 内存分析(pxw @0x903c)确认目标地址0x1752e；4) strcpy调用点无净化操作。攻击者通过argv[2]可完全控制复制数据长度和内容，触发缓冲区溢出。POC：./program arg1 $(python -c 'print "A"*500') 可导致崩溃。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_WNR3500Lv2-V1.2.0.46_40.0.86.chk.extracted/squashfs-root/usr/sbin/rtsol
  Taint Propagation Path:
    - Source: pcVar7[2] (RA packet option data) in sym.process @0x004012a0
    - Step: unaff_s7 = pcVar7[2] --> Tainted RA data assigned to register
    - Step: sprintf(auStack_568, "%d", unaff_s7) @0x004015d4 --> Format tainted data into string buffer
    - Sink: nvram_set("ipv6_wan_length", auStack_568) @0x401824 --> Tainted buffer passed to NVRAM set
  Reason: 线索描述路径不存在（sprintf目标缓冲区错误/nvram_set地址错误），但验证发现真实可利用路径：1) 反编译证明unaff_s7直接来自RA包(pcVar7[2]) 2) sprintf将污染数据写入auStack_568 3) 0x401824处nvram_set将auStack_568设置到ipv6_wan_length。攻击者可通过RA包完全控制unaff_s7值，经格式化后直接写入NVRAM变量。POC：发送特制RA包使pcVar7[2]=255，将导致ipv6_wan_length设置为'255'。
</finding>
<finding>
  Binary Path: TP_Link/analyzed/TD_W9970_V1_150831/_TD-W9970v1_0.9.1_2.5_up_boot_2015-08-31_17.13.22.bin.extracted/squashfs-root/usr/sbin/handle_card
  Taint Propagation Path:
    - Source: fopen('/var/run/manual_switch.conf') in sym.getManualSwitchCmds @ 0x405718
    - Step: 0x00405adc: jalr t9 (strcpy) --> 文件内容通过strcpy复制到调用者提供的缓冲区param_3
    - Step: 0x0040cd9c: jal sym.modeSwitchByCmd --> 污点缓冲区作为第三参数(arg3)传递给modeSwitchByCmd
    - Step: 0x00409610: jalr t9 (sprintf) --> sprintf(auStack_188, "usb_modeswitch -v 0x%04x -p 0x%04x -I -W %s &", ..., param_3) 污点数据作为%s参数
    - Sink: 0x00409668: jalr t9 (system) --> system(auStack_188) 格式化后的污点字符串直接执行
  Reason: 基于r2证据链：1) 污点源fopen读取用户可控文件 2) strcpy复制内容到缓冲区 3) 缓冲区作为参数传递给modeSwitchByCmd 4) sprintf未净化即格式化命令字符串 5) system直接执行含污点数据的命令。POC：向/var/run/manual_switch.conf写入';malicious_command;'可实现命令注入。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/debug_logd
  Taint Propagation Path:
    - Source: fopen("/tmp/debug_sta_info", "r") @0x8f48 (伪代码: iVar1 = sym.imp.fopen(*0x9054,*0x9058))
    - Step: fgets(auStack_f8, 0x80, file_ptr) @0x9020 --> 读取用户控制数据到缓冲区
    - Step: sscanf(auStack_f8, "%s %s", var1, var2) @0x8fe0 --> var2(iVar3)被污染
    - Step: sprintf(cmd_buf, [format], var2) @0x8ff0 (伪代码: sym.imp.sprintf(puVar5-0x1e0,*0x906c,iVar3)) --> 构造第一条命令
    - Sink: system(cmd_buf) @0x8ff8 (伪代码: sym.imp.system(puVar5-0x1e0)) --> 执行未净化数据
    - Step: sprintf(cmd_buf, "wl ratedump %s...", var2) @0x9008 (伪代码: sym.imp.sprintf(...,*0x9070,iVar3)) --> 第二条命令构造
    - Sink: system(cmd_buf) @0x9010 (伪代码: sym.imp.system(...)) --> 二次执行未净化数据
  Reason: 证据链确认：1) 文件路径可被攻击者控制 2) var2通过sscanf解析未经验证 3) 两个system()直接执行含var2的命令。POC：在/tmp/debug_sta_info写入'任意字符串 恶意命令'即可触发命令注入。但线索中0x906c地址无效，实际第一个格式字符串地址需修正（反编译显示使用*0x906c但该地址无效）
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7300-V1.0.0.56_1.0.18/fw/_R7300-V1.0.0.56_1.0.18.chk.extracted/squashfs-root/usr/sbin/arp_check
  Taint Propagation Path:
    - Source: fgets(buf, 0xff, fp) @0xa9d0 (fp from fopen("/proc/net/wandev"))
    - Step: bl sym.imp.sscanf(buf, "%08X %02x:%02x:%02x:%02x:%02x:%02x", &stack_var) @0xaa2c --> 解析16进制值到栈变量
    - Step: ldr sl, [sp, 0x40]; rev sl, sl @0xaa30-0xaa3c --> 加载并字节交换解析值
    - Step: bl sym.imp.sprintf(r4, "echo \"tmp_ip %08x\" >> /tmp/wan_detect_log", sl) @0xaa44 --> 污点值sl作为%08x参数
    - Sink: bl sym.imp.system(r4) @0xaa4c --> 执行格式化命令
  Reason: 基于r2证据：1) /proc/net/wandev路径存在(0xbbd4)；2) sscanf解析无校验；3) 字节交换后直接用于sprintf格式化；4) system执行未过滤。POC：控制/proc/net/wandev输入'41414141'，将执行'echo "tmp_ip 41414141" >> /tmp/wan_detect_log'，证明整数注入漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_XR500-V2.1.0.4.img.extracted/squashfs-root/usr/sbin/ssidsteering
  Taint Propagation Path:
    - Source: fgets(puVar15 - 0x2e0, 0x200, config_file) @ 0x89b4 --> 配置文件内容用户可控 (pdg @ fcn.00008774确认)
    - Step: strcpy(puVar15 - 0xac, input) @ 0x8a5c --> 污点数据复制到栈缓冲区 (pd 20 @0x8a5c确认)
    - Step: bl fcn.00008e80 @ 0x8a9c --> 进入子函数处理污点数据 (pd 10 @0x8a90确认实际调用点)
    - Step: mov r7, r0 @ 0x8e8c --> 保存污点指针到r7 (pd @0x8e8c确认)
    - Step: mov r1, r7 @ 0x8ecc --> 污点数据地址作为strncpy源参数 (pd @0x8ecc确认)
    - Step: mov r0, sp @ 0x8ed4 --> 设置栈目标地址 (pd @0x8ed4确认)
    - Step: strncpy(r0, r1, 0x10) @ 0x8ef8 --> 复制污点数据到栈缓冲区 (pd @0x8ef8确认)
    - Sink: bl sym.imp.ioctl(fd, 0x8be0, sp) @ 0x8f14 --> 污点缓冲区传入内核驱动 (pd 20 @0x8f00确认参数设置)
  Reason: 基于r2验证：1) fgets读取的配置文件内容用户可控 2) strcpy将数据复制到栈缓冲区后传入子函数 3) 子函数通过strncpy(固定长度0x10)复制到当前栈帧 4) ioctl直接使用栈指针(sp)作为参数传递至内核。证据链显示污点数据全程未净化，攻击者可构造恶意配置文件触发内核驱动漏洞。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/sbin/wwan
  Taint Propagation Path:
    - Source: External NVRAM variable accessed via sym.imp.acosNvramConfig_get @ 0x9840
    - Step: mov r1, r0 @ 0x9844 --> Tainted return value moved to strcpy source register
    - Sink: bl sym.imp.strcpy(r0, r1) @ 0x984c --> Tainted r1 passed as src argument
  Reason: Radare2反汇编证明：1) acosNvramConfig_get返回值(r0)直接移入strcpy的src参数寄存器(r1) 2) 0x9840-0x984c之间无修改r1的指令 3) 无长度校验或净化操作。POC：攻击者通过控制NVRAM变量可注入任意数据到strcpy，导致缓冲区溢出。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R6700-V1.0.1.36_10.0.40/fw/_R6700-V1.0.1.36_10.0.40.chk.extracted/squashfs-root/usr/sbin/check_fw
  Taint Propagation Path:
    - Source: bl sym.imp.acosNvramConfig_get @0xa174 → mov sb, r0 (污染username)
    - Source: bl sym.imp.acosNvramConfig_get @0xa180 → mov r7, r0 (污染password)
    - Source: bl sym.imp.acosNvramConfig_get @0xa19c → mov sl, r0 (污染config_file)
    - Step: mov r3, sb @0xa1b0; stm sp, {r7} @0xa1c4; str sl, [sp+0x10] @0xa1d0 → 污染值加载到sprintf参数
    - Step: bl sym.imp.sprintf @0xa1d4 → 污染数据嵌入命令模板
    - Sink: mov r0, r6 @0xa1d8; bl sym.imp.system @0xa1dc → 执行未过滤命令
  Reason: Radare2证据链证实：1) 三个NVRAM值直接传入寄存器(sb/r9, r7, sl/r10) 2) 通过寄存器/栈传递到sprintf(0xa1b0-0xa1d0) 3) 格式化字符串含多个%s(地址0xc10c) 4) 污染缓冲区直接执行system()。POC：设置password=';malicious_command'可注入命令，威胁模型下攻击者拥有NVRAM写权限。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/R7000/fw/_R7000P-V1.3.0.8_1.0.93.chk.extracted/squashfs-root/sbin/wwan
  Taint Propagation Path:
    - Source: NVRAM variable 'wwan_runtime_manuf' accessed via acosNvramConfig_get @ 0x96f8
    - Step: ldr r0, str.wwan_runtime_manuf --> Loads variable name into r0 @ 0x96f8
    - Step: bl sym.imp.acosNvramConfig_get --> Retrieves tainted value to r0 @ 0x96fc
    - Step: mov r1, r0 --> Transfers tainted value to r1 @ 0x9700
    - Sink: bl sym.imp.strcpy --> Tainted r1 passed as src to strcpy @ 0x9708
  Reason: Radare2验证：1) 0x96f8指令ldr加载正确变量名；2) 0x96fc调用acosNvramConfig_get；3) 0x9700将返回值直接转移到strcpy的src参数(r1)；4) 0x9708调用strcpy时使用污点数据。攻击者（拥有合法凭证）可控制NVRAM值，路径中无长度检查或过滤，导致缓冲区溢出风险。POC：设置超长wwan_runtime_manuf值触发崩溃。
</finding>
<finding>
  Binary Path: d-link/analyzed/DIR-868L_fw_revA_1-12_eu_multi_20170316/fw/_DIR868LA1_FW112b04.bin.extracted/squashfs-root/usr/sbin/updateleases
  Taint Propagation Path:
    - Source: -f参数指定文件的读取内容（外部可控）
    - Step: 0x959c: bl sym.imp.fread(piVar6-0x3c4, 0x5c, 1, file_ptr) --> 读取92字节文件内容到栈缓冲区
    - Step: 0x938c: mov r0, piVar6-0x7e0; mov r1, piVar6-0x3a8; bl sym.imp.strcpy --> 从fread缓冲区偏移0x1c处复制数据
    - Sink: strcpy @ 0x938c 写入固定大小栈缓冲区acStack_274（254字节）
  Reason: 证据链：1) 文件路径由-f参数控制（strncpy复制到piVar6-0x160） 2) fopen打开文件后fread读取92字节到栈（0x959c） 3) strcpy源地址piVar6-0x3a8在fread缓冲区内（piVar6-0x3c4 + 0x1c） 4) 目标缓冲区acStack_274[254]在函数栈帧中，strcpy无长度检查。攻击者构造92字节文件，使偏移0x1c处字符串>254字节可覆盖返回地址。
</finding>
<finding>
  Binary Path: NETGEAR/analyzed/_XR500-V2.1.0.4.img.extracted/squashfs-root/www/cgi-bin/proccgi
  Taint Propagation Path:
    - Source: getenv("CGI_POST_TMPFILE") @ 0x8828: ldr r0, [0x8950] → r0 = "CGI_POST_TMPFILE"
    - Step: 0x882c: bl sym.imp.getenv → r0 = tainted_env_value
    - Step: 0x8830: ldr r1, [0x8d04] → r1 = "r" (模式参数)
    - Sink: 0x8834: bl sym.imp.fopen(r0, r1) → 污点值直接作为文件名参数
  Reason: 通过r2验证：1) 0x8950内存包含'CGI_POST_TMPFILE'字符串指针 2) 汇编显示getenv返回值(r0)未经修改直接传递到fopen 3) 攻击者可通过环境变量控制文件名参数 4) 文件读取操作可能泄露敏感数据。POC：设置CGI_POST_TMPFILE=/etc/passwd可读取系统密码文件。
</finding>
